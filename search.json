[
  {
    "objectID": "pages/slides.html#a-bit-of-background-about-me-and-this-work",
    "href": "pages/slides.html#a-bit-of-background-about-me-and-this-work",
    "title": "Geospatial reprojection in Python",
    "section": "A bit of background about me and this work",
    "text": "A bit of background about me and this work",
    "crumbs": [
      "Overview Slides"
    ]
  },
  {
    "objectID": "pages/slides.html#caveats",
    "href": "pages/slides.html#caveats",
    "title": "Geospatial reprojection in Python",
    "section": "Caveats",
    "text": "Caveats\n\nWork in progress!\nRecording will quickly become out-of-date\nVerify/fix code before use",
    "crumbs": [
      "Overview Slides"
    ]
  },
  {
    "objectID": "pages/slides.html#definitions",
    "href": "pages/slides.html#definitions",
    "title": "Geospatial reprojection in Python",
    "section": "Definitions",
    "text": "Definitions\nReprojection - changing the projection of a dataset from one coordinate reference system (CRS) to another",
    "crumbs": [
      "Overview Slides"
    ]
  },
  {
    "objectID": "pages/slides.html#definitions-1",
    "href": "pages/slides.html#definitions-1",
    "title": "Geospatial reprojection in Python",
    "section": "Definitions",
    "text": "Definitions\nResampling/regridding - changing the grid structure (often resolution)",
    "crumbs": [
      "Overview Slides"
    ]
  },
  {
    "objectID": "pages/slides.html#definitions-2",
    "href": "pages/slides.html#definitions-2",
    "title": "Geospatial reprojection in Python",
    "section": "Definitions",
    "text": "Definitions\nWarp resampling - changing the resolution and projection of a dataset",
    "crumbs": [
      "Overview Slides"
    ]
  },
  {
    "objectID": "pages/slides.html#grid-structures",
    "href": "pages/slides.html#grid-structures",
    "title": "Geospatial reprojection in Python",
    "section": "Grid structures",
    "text": "Grid structures\n\nRectilinear - described by one-dimensional latitude and longitude coordinates\n\nRegular - described by one x,y coordinate and the resolution\n\nCurvilinear - described by two-dimensional latitude and longitude coordinates\nUnstructured - Grids in which the grid coordinates require a list of nodes\n\n\nReview NCAR’s climate data guide for more information",
    "crumbs": [
      "Overview Slides"
    ]
  },
  {
    "objectID": "pages/slides.html#resampling-algorithms",
    "href": "pages/slides.html#resampling-algorithms",
    "title": "Geospatial reprojection in Python",
    "section": "Resampling algorithms",
    "text": "Resampling algorithms\n\nNearest neighbor\nBilinear\nCubic\nSpline\nInverse distance\nBucket / binning (average, min, max, mode, med, quartile, sum, rms)\nSpectral\nTriangulation\nConservative\n\n\nReview NCAR’s climate data guide for more information",
    "crumbs": [
      "Overview Slides"
    ]
  },
  {
    "objectID": "pages/slides.html#some-of-the-many-reasons-to-warp-resample",
    "href": "pages/slides.html#some-of-the-many-reasons-to-warp-resample",
    "title": "Geospatial reprojection in Python",
    "section": "Some of the many reasons to warp resample",
    "text": "Some of the many reasons to warp resample\nCo-registering datasets\n\nMosaicing\nStatistical analyses\nMachine learning\n\nVisualization\n\nRendering (minimize distortion)\nBuilding overviews",
    "crumbs": [
      "Overview Slides"
    ]
  },
  {
    "objectID": "pages/slides.html#observations-and-opinions",
    "href": "pages/slides.html#observations-and-opinions",
    "title": "Geospatial reprojection in Python",
    "section": "Observations and opinions",
    "text": "Observations and opinions\n\nLots of kernels were killed in the making of this presentation\n\nwe need a demo using a bounded-memory approach (Cubed!)\n\nThere are some awesome data cube libraries in Python\n\nlet’s work with the developers to make them even better…and not build another one\n\nXarray’s data model is intuitive for a lot of people\n\nuse accessors to extend it’s functionality rather than a new data class",
    "crumbs": [
      "Overview Slides"
    ]
  },
  {
    "objectID": "pages/slides.html#whats-next-for-the-guide",
    "href": "pages/slides.html#whats-next-for-the-guide",
    "title": "Geospatial reprojection in Python",
    "section": "What’s next for the guide",
    "text": "What’s next for the guide\n\nTry caching weights\nSmall tile from a large dataset\nAdd information about grid structures supported\nAdd information about resampling methods supported\nTest with virtualized data\nTest with cloud optimized data\nTest with other resampling algorithms",
    "crumbs": [
      "Overview Slides"
    ]
  },
  {
    "objectID": "pages/slides.html#thanks",
    "href": "pages/slides.html#thanks",
    "title": "Geospatial reprojection in Python",
    "section": "Thanks",
    "text": "Thanks\n\nDevelopment Seed\nPangeo Community\n\nspecial thanks to Justus, Michael, and Deepak\n\nNASA IMPACT",
    "crumbs": [
      "Overview Slides"
    ]
  },
  {
    "objectID": "pages/slides.html#whats-next-for-resampling-in-python",
    "href": "pages/slides.html#whats-next-for-resampling-in-python",
    "title": "Geospatial reprojection in Python",
    "section": "What’s next for resampling in Python",
    "text": "What’s next for resampling in Python\nLet’s discuss!",
    "crumbs": [
      "Overview Slides"
    ]
  },
  {
    "objectID": "examples/run-pyinstrument.html",
    "href": "examples/run-pyinstrument.html",
    "title": "Geospatial reprojection in Python (2024)",
    "section": "",
    "text": "import subprocess\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Literal\n\nimport fsspec\nfrom utils import sync_notebook\n\n\nfs = fsspec.filesystem(\"file\")\ncurrent_date = datetime.today().strftime(\"%Y-%m-%d\")\noutput_folder = f\"results/{current_date}/\"\nfs.mkdirs(output_folder, exist_ok=True)\n\n\ndataset = \"mursst\"\n\n\ndef run_pyinstrument(file: str, output_format: Literal[\"json\", \"html\"]):\n    output_file = (\n        output_folder\n        + \"pyinstrument-\"\n        + dataset\n        + \"-\"\n        + Path(file).stem\n        + \".\"\n        + output_format\n    )\n    command = [\n        \"pyinstrument\",\n        \"--outfile\",\n        output_file,\n        \"-r\",\n        output_format,\n        file,\n        \"--dataset\",\n        dataset,\n    ]\n    subprocess.run(command)\n\n\nif dataset == \"gpm_imerg\":\n    input_methods = [\"rioxarray\", \"odc\", \"pyresample\", \"rioxarray\", \"xesmf\"]\nelif dataset == \"mursst\":\n    input_methods = [\"odc\", \"pyresample\", \"rioxarray\", \"rasterio\"]\n\n\nnotebooks = []\nfor fp in input_methods:\n    notebooks.extend(fs.glob(f\"resample-{fp}*.ipynb\"))\n\n\nfor file in notebooks:\n    sync_notebook(file)\n\n\nmodules = []\nfor fp in input_methods:\n    modules.extend(fs.glob(f\"resample-{fp}*.py\"))\nfor file in modules:\n    # Skip kerchunk since it requires a different image build due to incompatibility with Zarr V3\n    if \"kerchunk\" not in file:\n        run_pyinstrument(file, \"json\")\n\n\nmodules"
  },
  {
    "objectID": "examples/resample-xesmfcached-zarrv3-icechunk.html",
    "href": "examples/resample-xesmfcached-zarrv3-icechunk.html",
    "title": "Resampling with XESMF (S3 storage, Zarr V3 store, Zarr reader with icechunk)¶",
    "section": "",
    "text": "import argparse\n\nimport numpy as np\nimport xarray as xr\nimport xesmf as xe\nfrom icechunk import IcechunkStore, StorageConfig\n\n\ndef _reconstruct_xesmf_weights(ds_w):\n    \"\"\"\n    Reconstruct weights into format that xESMF understands\n\n    Notes\n    -----\n    From ndpyramid - https://github.com/carbonplan/ndpyramid\n    \"\"\"\n    import sparse\n    import xarray as xr\n\n    col = ds_w[\"col\"].values - 1\n    row = ds_w[\"row\"].values - 1\n    s = ds_w[\"S\"].values\n    n_out, n_in = ds_w.attrs[\"n_out\"], ds_w.attrs[\"n_in\"]\n    crds = np.stack([row, col])\n    return xr.DataArray(\n        sparse.COO(crds, s, (n_out, n_in)), dims=(\"out_dim\", \"in_dim\"), name=\"weights\"\n    )\n\n\ndef regrid(dataset):\n    from common import earthaccess_args  # noqa: 402\n\n    args = earthaccess_args[dataset]\n    # Load pre-generated weights and target dataset\n    weights_storage = StorageConfig.s3_from_env(\n        bucket=\"nasa-veda-scratch\",\n        prefix=f\"resampling/test-weight-caching/{dataset}-weights\",\n        region=\"us-west-2\",\n    )\n    target_storage = StorageConfig.s3_from_env(\n        bucket=\"nasa-veda-scratch\",\n        prefix=f\"resampling/test-weight-caching/{dataset}-target\",\n        region=\"us-west-2\",\n    )\n    weights_store = IcechunkStore.open_existing(storage=weights_storage, mode=\"r\")\n    target_store = IcechunkStore.open_existing(storage=target_storage, mode=\"r\")\n    weights = _reconstruct_xesmf_weights(\n        xr.open_zarr(weights_store, zarr_format=3, consolidated=False)\n    )\n    grid = xr.open_zarr(target_store, zarr_format=3, consolidated=False)\n    # Open dataset\n    storage = StorageConfig.s3_from_env(\n        bucket=\"nasa-veda-scratch\",\n        prefix=f\"resampling/icechunk/{dataset}\",\n        region=\"us-west-2\",\n    )\n    store = IcechunkStore.open_existing(storage=storage, mode=\"r\")\n    da = xr.open_zarr(store, zarr_format=3, consolidated=False)[args[\"variable\"]]\n    # Create XESMF regridder\n    regridder = xe.Regridder(\n        da,\n        grid,\n        \"nearest_s2d\",\n        periodic=True,\n        extrap_method=\"nearest_s2d\",\n        ignore_degenerate=True,\n        reuse_weights=True,\n        weights=weights,\n    )\n    # Regrid dataset\n    return regridder(da)\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = regrid(\"gpm_imerg\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"gpm_imerg\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = regrid(user_args.dataset)"
  },
  {
    "objectID": "examples/resample-xesmfcached-zarr-icechunk.html",
    "href": "examples/resample-xesmfcached-zarr-icechunk.html",
    "title": "Resampling with XESMF (S3 storage, NetCDF file, Zarr reader, icechunk virtualization, and pre-generated weights)",
    "section": "",
    "text": "import argparse\n\nimport numpy as np\nimport xarray as xr\nimport xesmf as xe\nfrom icechunk import IcechunkStore, StorageConfig\n\n\ndef _reconstruct_xesmf_weights(ds_w):\n    \"\"\"\n    Reconstruct weights into format that xESMF understands\n\n    Notes\n    -----\n    From ndpyramid - https://github.com/carbonplan/ndpyramid\n    \"\"\"\n    import sparse\n    import xarray as xr\n\n    col = ds_w[\"col\"].values - 1\n    row = ds_w[\"row\"].values - 1\n    s = ds_w[\"S\"].values\n    n_out, n_in = ds_w.attrs[\"n_out\"], ds_w.attrs[\"n_in\"]\n    crds = np.stack([row, col])\n    return xr.DataArray(\n        sparse.COO(crds, s, (n_out, n_in)), dims=(\"out_dim\", \"in_dim\"), name=\"weights\"\n    )\n\n\ndef regrid(dataset):\n    from common import earthaccess_args  # noqa: 402\n\n    args = earthaccess_args[dataset]\n    # Load pre-generated weights and target dataset\n    weights_storage = StorageConfig.s3_from_env(\n        bucket=\"nasa-veda-scratch\",\n        prefix=f\"resampling/test-weight-caching/{dataset}-weights\",\n        region=\"us-west-2\",\n    )\n    target_storage = StorageConfig.s3_from_env(\n        bucket=\"nasa-veda-scratch\",\n        prefix=f\"resampling/test-weight-caching/{dataset}-target\",\n        region=\"us-west-2\",\n    )\n    weights_store = IcechunkStore.open_existing(storage=weights_storage, mode=\"r\")\n    target_store = IcechunkStore.open_existing(storage=target_storage, mode=\"r\")\n    weights = _reconstruct_xesmf_weights(\n        xr.open_zarr(weights_store, zarr_format=3, consolidated=False)\n    )\n    grid = xr.open_zarr(target_store, zarr_format=3, consolidated=False)\n    # Open dataset\n    storage = StorageConfig.s3_from_env(\n        bucket=\"nasa-veda-scratch\",\n        prefix=f\"resampling/icechunk/{dataset}-reference\",\n        region=\"us-west-2\",\n    )\n    store = IcechunkStore.open_existing(storage=storage, mode=\"r\")\n    da = xr.open_zarr(store, zarr_format=3, consolidated=False)[args[\"variable\"]]\n    # Create XESMF regridder\n    regridder = xe.Regridder(\n        da,\n        grid,\n        \"nearest_s2d\",\n        periodic=True,\n        extrap_method=\"nearest_s2d\",\n        ignore_degenerate=True,\n        reuse_weights=True,\n        weights=weights,\n    )\n    # Regrid dataset\n    return regridder(da)\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = regrid(\"gpm_imerg\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"gpm_imerg\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = regrid(user_args.dataset)",
    "crumbs": [
      "Resampling libraries",
      "XESMF (with pre-generated weights)",
      "Zarr Reader + Icechunk virtualization(S3 storage)"
    ]
  },
  {
    "objectID": "examples/resample-xesmfcached-h5netcdf-.html",
    "href": "examples/resample-xesmfcached-h5netcdf-.html",
    "title": "Resampling with XESMF (S3 storage, NetCDF file, H5NetCDF driver, earthaccess auth, and pre-generated weights)",
    "section": "",
    "text": "import argparse\n\nimport earthaccess\nimport numpy as np\nimport xarray as xr\nimport xesmf as xe\n\n\ndef _reconstruct_xesmf_weights(ds_w):\n    \"\"\"\n    Reconstruct weights into format that xESMF understands\n\n    Notes\n    -----\n    From ndpyramid - https://github.com/carbonplan/ndpyramid\n    \"\"\"\n    import sparse\n    import xarray as xr\n\n    col = ds_w[\"col\"].values - 1\n    row = ds_w[\"row\"].values - 1\n    s = ds_w[\"S\"].values\n    n_out, n_in = ds_w.attrs[\"n_out\"], ds_w.attrs[\"n_in\"]\n    crds = np.stack([row, col])\n    return xr.DataArray(\n        sparse.COO(crds, s, (n_out, n_in)), dims=(\"out_dim\", \"in_dim\"), name=\"weights\"\n    )\n\n\ndef reconstruct_weights(weights_fp):\n    \"\"\"\n    Reconstruct weights into format that xESMF understands\n\n    Notes\n    -----\n    From ndpyramid - https://github.com/carbonplan/ndpyramid\n    \"\"\"\n    return _reconstruct_xesmf_weights(xr.open_zarr(weights_fp))\n\n\ndef regrid(dataset):\n    from common import earthaccess_args  # noqa: 402\n\n    args = earthaccess_args[dataset]\n    # Load pre-generated weights and target dataset\n    weights_fp = (\n        \"s3://nasa-veda-scratch/resampling/test-weight-caching/\"\n        + dataset\n        + \"-weights.zarr\"\n    )\n    target_grid_fp = (\n        \"s3://nasa-veda-scratch/resampling/test-weight-caching/\"\n        + dataset\n        + \"-target.zarr\"\n    )\n    weights = reconstruct_weights(weights_fp)\n    grid = xr.open_zarr(target_grid_fp)\n    # Define filepath, driver, and variable information\n    input_uri = f'{args[\"folder\"]}/{args[\"filename\"]}'\n    src = f's3://{args[\"bucket\"]}/{input_uri}'\n    # Authenticate with earthaccess\n    fs = earthaccess.get_s3_filesystem(daac=args[\"daac\"])\n    # Specify fsspec caching since default options don't work well for raster data\n    fsspec_caching = {\n        \"cache_type\": \"none\",\n    }\n    with fs.open(src, **fsspec_caching) as f:\n        # Open dataset\n        da = xr.open_dataset(f, engine=\"h5netcdf\", mask_and_scale=True)[\n            args[\"variable\"]\n        ]\n        # Create XESMF regridder\n        regridder = xe.Regridder(\n            da,\n            grid,\n            \"nearest_s2d\",\n            periodic=True,\n            extrap_method=\"nearest_s2d\",\n            ignore_degenerate=True,\n            reuse_weights=True,\n            weights=weights,\n        )\n        # Regrid dataset\n        return regridder(da).load()\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = regrid(\"gpm_imerg\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"gpm_imerg\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = regrid(user_args.dataset)",
    "crumbs": [
      "Resampling libraries",
      "XESMF (with pre-generated weights)",
      "H5NetCDF Driver (S3 storage)"
    ]
  },
  {
    "objectID": "examples/resample-xesmf-zarr-icechunk.html",
    "href": "examples/resample-xesmf-zarr-icechunk.html",
    "title": "Resampling with XESMF (S3 storage, NetCDF file, Zarr reader, icechunk virtualization)",
    "section": "",
    "text": "import argparse\nimport itertools\n\nimport numpy as np\nimport pyproj\nimport rasterio.transform\nimport xarray as xr\nimport xesmf as xe\nfrom icechunk import IcechunkStore, StorageConfig\n\n\ndef make_grid_ds(*, te, tilesize, dstSRS) -&gt; xr.Dataset:\n    \"\"\"\n    Make a dataset representing a target grid\n\n    Returns\n    -------\n    xr.Dataset\n        Target grid dataset with the following variables:\n        - \"x\": X coordinate in Web Mercator projection (grid cell center)\n        - \"y\": Y coordinate in Web Mercator projection (grid cell center)\n        - \"lat\": latitude coordinate (grid cell center)\n        - \"lon\": longitude coordinate (grid cell center)\n        - \"lat_b\": latitude bounds for grid cell\n        - \"lon_b\": longitude bounds for grid cell\n\n    Notes\n    -----\n    Modified from ndpyramid - https://github.com/carbonplan/ndpyramid\n    \"\"\"\n\n    transform = rasterio.transform.Affine.translation(\n        te[0], te[3]\n    ) * rasterio.transform.Affine.scale((te[2] * 2) / tilesize, (te[1] * 2) / tilesize)\n\n    p = pyproj.Proj(dstSRS)\n\n    grid_shape = (tilesize, tilesize)\n    bounds_shape = (tilesize + 1, tilesize + 1)\n\n    xs = np.empty(grid_shape)\n    ys = np.empty(grid_shape)\n    lat = np.empty(grid_shape)\n    lon = np.empty(grid_shape)\n    lat_b = np.zeros(bounds_shape)\n    lon_b = np.zeros(bounds_shape)\n\n    # calc grid cell center coordinates\n    ii, jj = np.meshgrid(np.arange(tilesize) + 0.5, np.arange(tilesize) + 0.5)\n    for i, j in itertools.product(range(grid_shape[0]), range(grid_shape[1])):\n        locs = [ii[i, j], jj[i, j]]\n        xs[i, j], ys[i, j] = transform * locs\n        lon[i, j], lat[i, j] = p(xs[i, j], ys[i, j], inverse=True)\n\n    # calc grid cell bounds\n    iib, jjb = np.meshgrid(np.arange(tilesize + 1), np.arange(tilesize + 1))\n    for i, j in itertools.product(range(bounds_shape[0]), range(bounds_shape[1])):\n        locs = [iib[i, j], jjb[i, j]]\n        x, y = transform * locs\n        lon_b[i, j], lat_b[i, j] = p(x, y, inverse=True)\n\n    return xr.Dataset(\n        {\n            \"x\": xr.DataArray(xs[0, :], dims=[\"x\"]),\n            \"y\": xr.DataArray(ys[:, 0], dims=[\"y\"]),\n            \"lat\": xr.DataArray(lat, dims=[\"y\", \"x\"]),\n            \"lon\": xr.DataArray(lon, dims=[\"y\", \"x\"]),\n            \"lat_b\": xr.DataArray(lat_b, dims=[\"y_b\", \"x_b\"]),\n            \"lon_b\": xr.DataArray(lon_b, dims=[\"y_b\", \"x_b\"]),\n        },\n    )\n\n\ndef regrid(dataset):\n    from common import earthaccess_args\n    from common import target_extent as te\n\n    # Define filepath, driver, and variable information\n    args = earthaccess_args[dataset]\n    # Create grid to hold result\n    target_grid = make_grid_ds(te=te, tilesize=256, dstSRS=\"EPSG:3857\")\n    # Open dataset\n    storage = StorageConfig.s3_from_env(\n        bucket=\"nasa-veda-scratch\",\n        prefix=f\"resampling/icechunk/{dataset}-reference\",\n        region=\"us-west-2\",\n    )\n    store = IcechunkStore.open_existing(storage=storage, mode=\"r\")\n    da = xr.open_zarr(store, zarr_format=3, consolidated=False)[args[\"variable\"]]\n    # Create XESMF regridder\n    regridder = xe.Regridder(\n        da,\n        target_grid,\n        \"nearest_s2d\",\n        periodic=True,\n        extrap_method=\"nearest_s2d\",\n        ignore_degenerate=True,\n    )\n    # Regrid dataset\n    return regridder(da).load()\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = regrid(\"gpm_imerg\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = regrid(user_args.dataset)",
    "crumbs": [
      "Resampling libraries",
      "XESMF",
      "Zarr Reader + Icechunk virtualization (S3 storage)"
    ]
  },
  {
    "objectID": "examples/resample-xesmf-h5netcdf-.html",
    "href": "examples/resample-xesmf-h5netcdf-.html",
    "title": "Resampling with XESMF (S3 storage, NetCDF file, H5NetCDF driver, earthaccess auth)",
    "section": "",
    "text": "import argparse\nimport itertools\n\nimport earthaccess\nimport numpy as np\nimport pyproj\nimport rasterio.transform\nimport xarray as xr\nimport xesmf as xe\n\n\ndef make_grid_ds(*, te, tilesize, dstSRS) -&gt; xr.Dataset:\n    \"\"\"\n    Make a dataset representing a target grid\n\n    Returns\n    -------\n    xr.Dataset\n        Target grid dataset with the following variables:\n        - \"x\": X coordinate in Web Mercator projection (grid cell center)\n        - \"y\": Y coordinate in Web Mercator projection (grid cell center)\n        - \"lat\": latitude coordinate (grid cell center)\n        - \"lon\": longitude coordinate (grid cell center)\n        - \"lat_b\": latitude bounds for grid cell\n        - \"lon_b\": longitude bounds for grid cell\n\n    Notes\n    -----\n    Modified from ndpyramid - https://github.com/carbonplan/ndpyramid\n    \"\"\"\n\n    transform = rasterio.transform.Affine.translation(\n        te[0], te[3]\n    ) * rasterio.transform.Affine.scale((te[2] * 2) / tilesize, (te[1] * 2) / tilesize)\n\n    p = pyproj.Proj(dstSRS)\n\n    grid_shape = (tilesize, tilesize)\n    bounds_shape = (tilesize + 1, tilesize + 1)\n\n    xs = np.empty(grid_shape)\n    ys = np.empty(grid_shape)\n    lat = np.empty(grid_shape)\n    lon = np.empty(grid_shape)\n    lat_b = np.zeros(bounds_shape)\n    lon_b = np.zeros(bounds_shape)\n\n    # calc grid cell center coordinates\n    ii, jj = np.meshgrid(np.arange(tilesize) + 0.5, np.arange(tilesize) + 0.5)\n    for i, j in itertools.product(range(grid_shape[0]), range(grid_shape[1])):\n        locs = [ii[i, j], jj[i, j]]\n        xs[i, j], ys[i, j] = transform * locs\n        lon[i, j], lat[i, j] = p(xs[i, j], ys[i, j], inverse=True)\n\n    # calc grid cell bounds\n    iib, jjb = np.meshgrid(np.arange(tilesize + 1), np.arange(tilesize + 1))\n    for i, j in itertools.product(range(bounds_shape[0]), range(bounds_shape[1])):\n        locs = [iib[i, j], jjb[i, j]]\n        x, y = transform * locs\n        lon_b[i, j], lat_b[i, j] = p(x, y, inverse=True)\n\n    return xr.Dataset(\n        {\n            \"x\": xr.DataArray(xs[0, :], dims=[\"x\"]),\n            \"y\": xr.DataArray(ys[:, 0], dims=[\"y\"]),\n            \"lat\": xr.DataArray(lat, dims=[\"y\", \"x\"]),\n            \"lon\": xr.DataArray(lon, dims=[\"y\", \"x\"]),\n            \"lat_b\": xr.DataArray(lat_b, dims=[\"y_b\", \"x_b\"]),\n            \"lon_b\": xr.DataArray(lon_b, dims=[\"y_b\", \"x_b\"]),\n        },\n    )\n\n\ndef regrid(dataset):\n    from common import earthaccess_args  # noqa: 402\n    from common import target_extent as te  # noqa: 402\n\n    # Define filepath, driver, and variable information\n    args = earthaccess_args[dataset]\n    input_uri = f'{args[\"folder\"]}/{args[\"filename\"]}'\n    src = f's3://{args[\"bucket\"]}/{input_uri}'\n    # Create grid to hold result\n    target_grid = make_grid_ds(te=te, tilesize=256, dstSRS=\"EPSG:3857\")\n    # Authenticate with earthaccess\n    fs = earthaccess.get_s3_filesystem(daac=args[\"daac\"])\n    # Specify fsspec caching since default options don't work well for raster data\n    fsspec_caching = {\n        \"cache_type\": \"none\",\n    }\n    with fs.open(src, **fsspec_caching) as f:\n        # Open dataset\n        da = xr.open_dataset(f, engine=\"h5netcdf\", chunks={}, mask_and_scale=True)[\n            args[\"variable\"]\n        ]\n        # Create XESMF regridder\n        regridder = xe.Regridder(\n            da,\n            target_grid,\n            \"nearest_s2d\",\n            periodic=True,\n            extrap_method=\"nearest_s2d\",\n            ignore_degenerate=True,\n        )\n        # Regrid dataset\n        return regridder(da).load()\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = regrid(\"gpm_imerg\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = regrid(user_args.dataset)",
    "crumbs": [
      "Resampling libraries",
      "XESMF",
      "H5NetCDF Driver (S3 storage)"
    ]
  },
  {
    "objectID": "examples/resample-rioxarray-zarr-icechunk.html",
    "href": "examples/resample-rioxarray-zarr-icechunk.html",
    "title": "Resampling with Rioxarray (S3 storage, NetCDF file, Zarr reader, icechunk virtualization)",
    "section": "",
    "text": "import argparse\n\nimport xarray as xr\nfrom icechunk import IcechunkStore, StorageConfig\nfrom rasterio.warp import calculate_default_transform\n\n\ndef warp_resample(dataset):\n    from common import earthaccess_args\n    from common import target_extent as te\n\n    # Define filepath, driver, and variable information\n    args = earthaccess_args[dataset]\n    # Open dataset\n    storage = StorageConfig.s3_from_env(\n        bucket=\"nasa-veda-scratch\",\n        prefix=f\"resampling/icechunk/{dataset}-reference\",\n        region=\"us-west-2\",\n    )\n    store = IcechunkStore.open_existing(storage=storage, mode=\"r\")\n    da = xr.open_zarr(store, zarr_format=3, consolidated=False)[args[\"variable\"]]\n    # Define source and target projection\n    dstSRS = \"EPSG:3857\"\n    srcSRS = \"EPSG:4326\"\n    width = height = 256\n    if dataset == \"gpm_imerg\":\n        # Transpose and rename dims to align with rioxarray expectations\n        da = da.rename({\"lon\": \"x\", \"lat\": \"y\"}).transpose(\"time\", \"y\", \"x\")\n    # Set input dataset projection\n    da = da.rio.write_crs(srcSRS)\n    da = da.rio.clip_box(\n        *te,\n        crs=dstSRS,\n    )\n    # Define affine transformation from input to output dataset\n    dst_transform, w, h = calculate_default_transform(\n        srcSRS,\n        dstSRS,\n        da.rio.width,\n        da.rio.height,\n        *da.rio.bounds(),\n        dst_width=width,\n        dst_height=height,\n    )\n    # Reproject dataset\n    return da.rio.reproject(dstSRS, shape=(h, w), transform=dst_transform)\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = warp_resample(\"mursst\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = warp_resample(user_args.dataset)"
  },
  {
    "objectID": "examples/resample-rioxarray-h5netcdf-.html",
    "href": "examples/resample-rioxarray-h5netcdf-.html",
    "title": "Resampling with Rioxarray (S3 storage, NetCDF file, H5NetCDF driver, earthaccess auth)",
    "section": "",
    "text": "import argparse\n\nimport earthaccess\nimport xarray as xr\nfrom rasterio.warp import calculate_default_transform\n\n\ndef warp_resample(dataset):\n    from common import earthaccess_args\n    from common import target_extent as te\n\n    # Define filepath, driver, and variable information\n    args = earthaccess_args[dataset]\n    input_uri = f'{args[\"folder\"]}/{args[\"filename\"]}'\n    src = f's3://{args[\"bucket\"]}/{input_uri}'\n    # Define source and target projection\n    dstSRS = \"EPSG:3857\"\n    srcSRS = \"EPSG:4326\"\n    width = height = 256\n    # Authenticate with earthaccess\n    fs = earthaccess.get_s3_filesystem(daac=args[\"daac\"])\n    # Specify fsspec caching since default options don't work well for raster data\n    fsspec_caching = {\n        \"cache_type\": \"none\",\n    }\n    with fs.open(src, **fsspec_caching) as f:\n        # Open dataset\n        da = xr.open_dataset(f, engine=\"h5netcdf\", mask_and_scale=True)[\n            args[\"variable\"]\n        ]\n        if dataset == \"gpm_imerg\":\n            # Transpose and rename dims to align with rioxarray expectations\n            da = da.rename({\"lon\": \"x\", \"lat\": \"y\"}).transpose(\"time\", \"y\", \"x\")\n        # Set input dataset projection\n        da = da.rio.write_crs(srcSRS)\n        da = da.rio.clip_box(\n            *te,\n            crs=dstSRS,\n        )\n        # Define affine transformation from input to output dataset\n        dst_transform, w, h = calculate_default_transform(\n            srcSRS,\n            dstSRS,\n            da.rio.width,\n            da.rio.height,\n            *da.rio.bounds(),\n            dst_width=width,\n            dst_height=height,\n        )\n        # Reproject dataset\n        return da.rio.reproject(dstSRS, shape=(h, w), transform=dst_transform)\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = warp_resample(\"gpm_imerg\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = warp_resample(user_args.dataset)",
    "crumbs": [
      "Resampling libraries",
      "Rioxarray",
      "H5NetCDF Driver (S3 storage)"
    ]
  },
  {
    "objectID": "examples/resample-rasterio-netcdf-local.html",
    "href": "examples/resample-rasterio-netcdf-local.html",
    "title": "Resampling with rasterio (Local storage, NetCDF File, NetCDF4 driver)",
    "section": "",
    "text": "import argparse\nimport json\n\nimport geopandas as gpd\nimport numpy as np\nimport rasterio\nfrom rasterio.mask import mask\nfrom rasterio.warp import reproject\nfrom shapely.geometry import box\n\n\ndef warp_resample(dataset):\n    from common import earthaccess_args\n    from common import target_extent as te\n\n    # Define filepath, driver, and variable information\n    args = earthaccess_args[dataset]\n    src = f'NETCDF:earthaccess_data/{args[\"filename\"]}:{args[\"variable\"]}'\n    # Define source and target projection\n    dstSRS = \"EPSG:3857\"\n    srcSRS = \"EPSG:4326\"\n    width = height = 256\n    with rasterio.open(src) as da:\n        # Clip dataset to bounds of Web Mercator tile\n        bbox = box(*te)\n        geo = gpd.GeoDataFrame(\n            {\"geometry\": bbox}, index=[0], crs=int(dstSRS.split(\":\")[1])\n        )\n        geo = geo.to_crs(crs=srcSRS)\n        coords = [json.loads(geo.to_json())[\"features\"][0][\"geometry\"]]\n        arr, src_transform = mask(da, shapes=coords, crop=True)\n        # Mask and fill array\n        ma = arr.astype(\"float32\", casting=\"unsafe\")\n        np.multiply(ma, da.scales[0], out=ma, casting=\"unsafe\")\n        np.add(ma, da.offsets[0], out=ma, casting=\"unsafe\")\n        # Define affine transformation from input to output dataset\n        dst_transform = rasterio.transform.from_bounds(*te, width, height)\n        # Create array to host results\n        destination = np.zeros((height, width), np.float32)\n        # Reproject dataset\n        _, transform = reproject(\n            ma.squeeze(),\n            destination,\n            src_crs=srcSRS,\n            src_transform=src_transform,\n            dst_crs=dstSRS,\n            dst_transform=dst_transform,\n        )\n        return destination\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = warp_resample(\"mursst\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = warp_resample(user_args.dataset)",
    "crumbs": [
      "Resampling libraries",
      "Rasterio",
      "NetCDF Driver (Local storage)"
    ]
  },
  {
    "objectID": "examples/resample-pyresample-zarr-icechunk.html",
    "href": "examples/resample-pyresample-zarr-icechunk.html",
    "title": "Resampling with pyresample (S3 storage, NetCDF file, Zarr reader, icechunk virtualization)",
    "section": "",
    "text": "import argparse\n\nimport xarray as xr\nfrom icechunk import IcechunkStore, StorageConfig\nfrom pyresample.area_config import create_area_def\nfrom pyresample.gradient import block_nn_interpolator, gradient_resampler_indices_block\nfrom pyresample.resampler import resample_blocks\n\n\ndef warp_resample(dataset):\n    from common import earthaccess_args\n    from common import target_extent as te\n\n    # Define filepath, driver, and variable information\n    args = earthaccess_args[dataset]\n    # Open dataset\n    storage = StorageConfig.s3_from_env(\n        bucket=\"nasa-veda-scratch\",\n        prefix=f\"resampling/icechunk/{dataset}-reference\",\n        region=\"us-west-2\",\n    )\n    store = IcechunkStore.open_existing(storage=storage, mode=\"r\")\n    da = xr.open_zarr(store, zarr_version=3, consolidated=False)[args[\"variable\"]]\n    # Define source and target projection\n    dstSRS = \"EPSG:3857\"\n    srcSRS = \"EPSG:4326\"\n    width = height = 256\n    # Rechunk MURSST to operate on fewer chunks\n    if dataset == \"mursst\":\n        da = da.chunk({\"time\": -1, \"lat\": 4000, \"lon\": 4000})\n    elif dataset == \"gpm_imerg\":\n        # Transpose dims to align with pyresample expectations\n        da = da.transpose(\"time\", \"lat\", \"lon\").squeeze()\n    # Create area definition for the target dataset\n    target_area_def = create_area_def(\n        area_id=1,\n        projection=dstSRS,\n        shape=(height, width),\n        area_extent=te,\n    )\n    # Create area definition for the source dataset\n    source_area_def = create_area_def(\n        area_id=2,\n        projection=srcSRS,\n        shape=(da.sizes[\"lat\"], da.sizes[\"lon\"]),\n        area_extent=[-179.995, 89.995, 180.005, -89.995],\n    )\n    # Compute indices for resampling\n    indices_xy = resample_blocks(\n        gradient_resampler_indices_block,\n        source_area_def,\n        [],\n        target_area_def,\n        chunk_size=(1, height, width),\n        dtype=float,\n    )\n    # Apply resampler\n    resampled = resample_blocks(\n        block_nn_interpolator,\n        source_area_def,\n        [da.data],\n        target_area_def,\n        dst_arrays=[indices_xy],\n        chunk_size=(1, height, width),\n        dtype=da.dtype,\n    )\n    # Reproject dataset\n    return resampled.compute()\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = warp_resample(\"mursst\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = warp_resample(user_args.dataset)"
  },
  {
    "objectID": "examples/resample-pyresample-h5netcdf-.html",
    "href": "examples/resample-pyresample-h5netcdf-.html",
    "title": "Resampling with pyresample (s3 storage, NetCDF File, H5NetCDF driver, earthaccess auth)",
    "section": "",
    "text": "import argparse\n\nimport earthaccess\nimport xarray as xr\nfrom pyresample.area_config import create_area_def\nfrom pyresample.gradient import block_nn_interpolator, gradient_resampler_indices_block\nfrom pyresample.resampler import resample_blocks\n\n\ndef warp_resample(dataset):\n    from common import earthaccess_args\n    from common import target_extent as te\n\n    # Define filepath, driver, and variable information\n    args = earthaccess_args[dataset]\n    input_uri = f'{args[\"folder\"]}/{args[\"filename\"]}'\n    src = f's3://{args[\"bucket\"]}/{input_uri}'\n    # Define source and target projection\n    dstSRS = \"EPSG:3857\"\n    srcSRS = \"EPSG:4326\"\n    width = height = 256\n    # Authentical via earthaccess\n    earthaccess.login()\n    fs = earthaccess.get_s3_filesystem(daac=args[\"daac\"])\n    # Specify fsspec caching since default options don't work well for raster data\n    fsspec_caching = {\n        \"cache_type\": \"none\",\n    }\n    with fs.open(src, **fsspec_caching) as f:\n        # Open dataset\n        da = xr.open_dataset(f, engine=\"h5netcdf\", chunks={})[args[\"variable\"]]\n        # Rechunk MURSST to operate on fewer chunks\n        if dataset == \"mursst\":\n            da = da.chunk({\"time\": -1, \"lat\": 4000, \"lon\": 4000})\n        elif dataset == \"gpm_imerg\":\n            # Transpose dims to align with pyresample expectations\n            da = da.transpose(\"time\", \"lat\", \"lon\").squeeze()\n        # Create area definition for the target dataset\n        target_area_def = create_area_def(\n            area_id=1,\n            projection=dstSRS,\n            shape=(height, width),\n            area_extent=te,\n        )\n        # Create area definition for the source dataset\n        source_area_def = create_area_def(\n            area_id=2,\n            projection=srcSRS,\n            shape=(da.sizes[\"lat\"], da.sizes[\"lon\"]),\n            area_extent=[-179.995, 89.995, 180.005, -89.995],\n        )\n        # Compute indices for resampling\n        indices_xy = resample_blocks(\n            gradient_resampler_indices_block,\n            source_area_def,\n            [],\n            target_area_def,\n            chunk_size=(1, height, width),\n            dtype=float,\n        )\n        # Apply resampler\n        resampled = resample_blocks(\n            block_nn_interpolator,\n            source_area_def,\n            [da.data],\n            target_area_def,\n            dst_arrays=[indices_xy],\n            chunk_size=(1, height, width),\n            dtype=da.dtype,\n        )\n        # Reproject dataset\n        return resampled.compute()\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = warp_resample(\"gpm_imerg\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = warp_resample(user_args.dataset)",
    "crumbs": [
      "Resampling libraries",
      "Pyresample",
      "H5NetCDF Driver (S3 storage)"
    ]
  },
  {
    "objectID": "examples/resample-odc-zarr-icechunk.html",
    "href": "examples/resample-odc-zarr-icechunk.html",
    "title": "Resampling with ODC-geo (S3 storage, NetCDF file, Zarr reader, icechunk virtualization)",
    "section": "",
    "text": "import argparse\n\nimport xarray as xr\nfrom icechunk import IcechunkStore, StorageConfig\nfrom odc.geo.geobox import GeoBox\nfrom odc.geo.geom import Geometry\nfrom odc.geo.xr import crop, xr_reproject\nfrom shapely.geometry import box\n\n\ndef warp_resample(dataset):\n    from common import earthaccess_args\n    from common import target_extent as te\n\n    # Define filepath, driver, and variable information\n    args = earthaccess_args[dataset]\n    # Open dataset\n    storage = StorageConfig.s3_from_env(\n        bucket=\"nasa-veda-scratch\",\n        prefix=f\"resampling/icechunk/{dataset}-reference\",\n        region=\"us-west-2\",\n    )\n    store = IcechunkStore.open_existing(storage=storage, mode=\"r\")\n    da = xr.open_zarr(store, zarr_version=3, consolidated=False)[args[\"variable\"]]\n    # Define source and target projection\n    dstSRS = \"EPSG:3857\"\n    srcSRS = \"EPSG:4326\"\n    width = height = 256\n    # Define ODC geobox for target tile\n    gbox = GeoBox.from_bbox(te, dstSRS, shape=(height, width))\n    if dataset == \"gpm_imerg\":\n        # Transpose and rename dataset dims to align with GDAL expectations\n        da = da.rename({\"lon\": \"x\", \"lat\": \"y\"}).transpose(\"time\", \"y\", \"x\").squeeze()\n    # Assign input projection\n    da = da.odc.assign_crs(srcSRS)\n    # Crop dataset to tile bounds\n    bbox = box(*te)\n    geom = Geometry(bbox, \"EPSG:3857\")\n    da = crop(da, geom)\n    if dataset == \"gpm_imerg\":\n        # Load into memory to avoid topology error\n        da.load()\n    # Reproject dataset\n    return xr_reproject(da, gbox, tight=True).load()\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = warp_resample(\"mursst\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = warp_resample(user_args.dataset)"
  },
  {
    "objectID": "examples/resample-odc-h5netcdf-.html",
    "href": "examples/resample-odc-h5netcdf-.html",
    "title": "Resampling with ODC-geo (s3 storage, NetCDF File, H5NetCDF driver, earthaccess auth)",
    "section": "",
    "text": "import argparse\n\nimport earthaccess\nimport xarray as xr\nfrom odc.geo.geobox import GeoBox\nfrom odc.geo.geom import Geometry\nfrom odc.geo.xr import crop, xr_reproject\nfrom shapely.geometry import box\n\n\ndef warp_resample(dataset):\n    from common import earthaccess_args\n    from common import target_extent as te\n\n    # Define filepath, driver, and variable information\n    args = earthaccess_args[dataset]\n    input_uri = f'{args[\"folder\"]}/{args[\"filename\"]}'\n    src = f's3://{args[\"bucket\"]}/{input_uri}'\n    # Define source and target projection\n    dstSRS = \"EPSG:3857\"\n    srcSRS = \"EPSG:4326\"\n    width = height = 256\n    # Authentical via earthaccess\n    earthaccess.login()\n    fs = earthaccess.get_s3_filesystem(daac=args[\"daac\"])\n    # Specify fsspec caching since default options don't work well for raster data\n    fsspec_caching = {\n        \"cache_type\": \"none\",\n    }\n    with fs.open(src, **fsspec_caching) as f:\n        # Define ODC geobox for target tile\n        gbox = GeoBox.from_bbox(te, dstSRS, shape=(height, width))\n        # Open dataset\n        da = xr.open_dataset(f, engine=\"h5netcdf\", chunks={})[args[\"variable\"]]\n        if dataset == \"gpm_imerg\":\n            # Transpose and rename dataset dims to align with GDAL expectations\n            da = (\n                da.rename({\"lon\": \"x\", \"lat\": \"y\"})\n                .transpose(\"time\", \"y\", \"x\")\n                .squeeze()\n            )\n        # Assign input projection\n        da = da.odc.assign_crs(srcSRS)\n        # Crop dataset to tile bounds\n        bbox = box(*te)\n        geom = Geometry(bbox, \"EPSG:3857\")\n        da = crop(da, geom)\n        if dataset == \"gpm_imerg\":\n            # Load into memory to avoid topology error\n            da.load()\n        # Reproject dataset\n        return xr_reproject(da, gbox, tight=True).load()\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = warp_resample(\"mursst\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = warp_resample(user_args.dataset)",
    "crumbs": [
      "Resampling libraries",
      "Open Data Cube",
      "H5NetCDF Driver (S3 storage)"
    ]
  },
  {
    "objectID": "examples/process-gpm-results.html",
    "href": "examples/process-gpm-results.html",
    "title": "Process results for GPM IMERG",
    "section": "",
    "text": "import hvplot.pandas  # noqa\nfrom utils import process_results\ndf = process_results(\"results/2024-10-22\").sort_values([\"duration (s)\"])",
    "crumbs": [
      "Profiling results",
      "Memory and time usage (GPM IMERG)"
    ]
  },
  {
    "objectID": "examples/process-gpm-results.html#show-memory-and-time-for-warp-resampling-dataset",
    "href": "examples/process-gpm-results.html#show-memory-and-time-for-warp-resampling-dataset",
    "title": "Process results for GPM IMERG",
    "section": "Show memory and time for warp resampling dataset",
    "text": "Show memory and time for warp resampling dataset\n\ndf = df[df[\"task\"] == \"resample\"]\ndf = df[df[\"virtual\"] != \"local\"]\ndf = df[df[\"dataset\"] == \"gpm_imerg\"]\ndf.style.background_gradient(cmap=\"YlOrRd\")\n\n\n\n\n\n\n \ndataset\ntask\nmethod\ndriver\nvirtual\npeak memory (GB)\nduration (s)\n\n\n\n\n11\ngpm_imerg\nresample\nrioxarray\nzarrv3\nicechunk\n0.214142\n3.056575\n\n\n7\ngpm_imerg\nresample\npyresample\nzarrv3\nicechunk\n0.497287\n3.060736\n\n\n10\ngpm_imerg\nresample\nrioxarray\nzarr\nicechunk\n0.213225\n3.157326\n\n\n6\ngpm_imerg\nresample\npyresample\nzarr\nicechunk\n0.503578\n3.260115\n\n\n2\ngpm_imerg\nresample\nodc\nzarr\nicechunk\n0.219031\n3.288107\n\n\n3\ngpm_imerg\nresample\nodc\nzarrv3\nicechunk\n0.221999\n4.279736\n\n\n4\ngpm_imerg\nresample\npyresample\nh5netcdf\n\n0.525762\n7.988237\n\n\n0\ngpm_imerg\nresample\nodc\nh5netcdf\n\n0.238357\n8.139791\n\n\n19\ngpm_imerg\nresample\nxesmfcached\nzarrv3\nicechunk\n0.402355\n9.050368\n\n\n8\ngpm_imerg\nresample\nrioxarray\nh5netcdf\n\n1.154217\n9.243863\n\n\n18\ngpm_imerg\nresample\nxesmfcached\nzarr\nicechunk\n0.402597\n9.685877\n\n\n16\ngpm_imerg\nresample\nxesmfcached\nh5netcdf\n\n0.436299\n10.158653\n\n\n15\ngpm_imerg\nresample\nxesmf\nzarrv3\nicechunk\n0.997981\n39.698240\n\n\n14\ngpm_imerg\nresample\nxesmf\nzarr\nicechunk\n0.999235\n39.921415\n\n\n12\ngpm_imerg\nresample\nxesmf\nh5netcdf\n\n1.020204\n43.978381",
    "crumbs": [
      "Profiling results",
      "Memory and time usage (GPM IMERG)"
    ]
  },
  {
    "objectID": "examples/earthdata-download.html",
    "href": "examples/earthdata-download.html",
    "title": "Download and virtualize dataset",
    "section": "",
    "text": "from pathlib import Path\n\nimport earthaccess\nfrom common import earthaccess_args\n\n\nSetup earthaccess query parameters\n\ndataset = \"gpm_imerg\"\ndataset_args = earthaccess_args[dataset]\nconcept_id = dataset_args[\"concept_id\"]\nfilename = dataset_args[\"filename\"]\nvariable = dataset_args[\"variable\"]\n\n\n\nAuthenticate via earthaccess\n\nearthaccess.login()\n\n\n\nDownload dataset\n\nresults = earthaccess.search_data(\n    concept_id=concept_id, count=1, temporal=(\"2002-06-01\", \"2002-06-01\")\n)\nfp = earthaccess.download(results, \"earthaccess_data\")[0]\n\n\n\nVirtualize dataset\n\nimport xarray as xr  # noqa\nimport zarr  # noqa\nfrom icechunk import (  # noqa\n    IcechunkStore,\n    S3Credentials,\n    StorageConfig,\n    StoreConfig,\n    VirtualRefConfig,\n)\nfrom virtualizarr import open_virtual_dataset  # noqa\nfrom virtualizarr.writers.icechunk import dataset_to_icechunk  # noqa\n\n\ndef virtualize_dataset(local_fp):\n    \"\"\"Create a virtual reference file for a dataset\"\"\"\n\n    def local_to_s3_url(old_local_path: str) -&gt; str:\n        \"\"\"Replace local path to s3 uri for all chucks\"\"\"\n\n        new_s3_bucket_url = Path(\"/\".join(s3_uri.split(\"/\")[1:-1]))\n        filename = Path(old_local_path).name\n        new_path = f\"s3:/{str(new_s3_bucket_url / filename)}\"\n        return new_path\n\n    s3_uri = results[0].data_links(access=\"direct\")[0]\n    virtual_ds = open_virtual_dataset(str(local_fp), indexes={})\n    virtual_ds = virtual_ds.virtualize.rename_paths(local_to_s3_url)\n    virtual_ds = virtual_ds[[variable]]\n    return virtual_ds.drop_vars(\"time\")\n\n\nvirtual_ds = virtualize_dataset(fp)\n\n\n\nStore virtual dataset as kerchunk reference\n\ns3_uri = results[0].data_links(access=\"direct\")[0]\nif dataset == \"gpm_merg\":\n    output_fp = f\"earthaccess_data/{s3_uri.split('/')[-1][:-4]}.json\"\nelse:\n    output_fp = f\"earthaccess_data/{s3_uri.split('/')[-1][:-3]}.json\"\nvirtual_ds.virtualize.to_kerchunk(output_fp, format=\"json\")\n\n\n\nStore virtual dataset using icechunk\n\ns3_creds = earthaccess.get_s3_credentials(daac=dataset_args[\"daac\"])\ncredentials = S3Credentials(\n    access_key_id=s3_creds[\"accessKeyId\"],\n    secret_access_key=s3_creds[\"secretAccessKey\"],\n    session_token=s3_creds[\"sessionToken\"],\n)\nstorage = StorageConfig.s3_from_env(\n    bucket=\"nasa-veda-scratch\",\n    prefix=f\"resampling/icechunk/{dataset}-reference\",\n    region=\"us-west-2\",\n)\nconfig = StoreConfig(\n    virtual_ref_config=VirtualRefConfig.s3_from_config(credentials=credentials),\n)\nvirtual_store = IcechunkStore.open_or_create(storage=storage, config=config, mode=\"w\")\ndataset_to_icechunk(virtual_ds, virtual_store)\nvirtual_store.commit(\"Create refenence dataset\")\n\n\n\nStore dataset using Zarr V3 and icechunk\n\nchunk_size = 4096\nvirtual_storage = StorageConfig.s3_from_env(\n    bucket=\"nasa-veda-scratch\",\n    prefix=f\"resampling/icechunk/{dataset}-reference\",\n    region=\"us-west-2\",\n)\nvirtual_store = IcechunkStore.open_existing(storage=virtual_storage, mode=\"r\")\nds = xr.open_zarr(virtual_store, zarr_format=3, consolidated=False).load()\nds = ds.drop_encoding()\nds = ds.squeeze()\nds = ds.chunk({\"lat\": chunk_size, \"lon\": chunk_size})\nif dataset == \"gpm_imerg\":\n    ds = ds.transpose(\"lat\", \"lon\")\nencoding = {\n    variable: {\n        \"codecs\": [zarr.codecs.BytesCodec(), zarr.codecs.ZstdCodec()],\n        \"chunks\": (chunk_size, chunk_size),\n    }\n}\nstorage = StorageConfig.s3_from_env(\n    bucket=\"nasa-veda-scratch\",\n    prefix=f\"resampling/icechunk/{dataset}\",\n    region=\"us-west-2\",\n)\nstore = IcechunkStore.open_or_create(storage=storage, mode=\"w\")\nds.to_zarr(store, zarr_format=3, consolidated=False, encoding=encoding)\nstore.commit(\"Add dataset\")",
    "crumbs": [
      "Dataset preparation",
      "Download and virtualize dataset"
    ]
  },
  {
    "objectID": "examples/generate-weights.html",
    "href": "examples/generate-weights.html",
    "title": "Geospatial reprojection in Python (2024)",
    "section": "",
    "text": "import itertools\nimport sys\n\nimport numpy as np\nimport pyproj\nimport rasterio.transform\nimport sparse\nimport xarray as xr\nimport xesmf as xe\nfrom icechunk import IcechunkStore, StorageConfig\n\n\nsys.path.append(\"..\")\n\n\ndataset = \"gpm_imerg\"\n\n\ndef make_grid_ds(*, te, tilesize, dstSRS) -&gt; xr.Dataset:\n    \"\"\"\n    Make a dataset representing a target grid\n\n    Returns\n    -------\n    xr.Dataset\n        Target grid dataset with the following variables:\n        - \"x\": X coordinate in Web Mercator projection (grid cell center)\n        - \"y\": Y coordinate in Web Mercator projection (grid cell center)\n        - \"lat\": latitude coordinate (grid cell center)\n        - \"lon\": longitude coordinate (grid cell center)\n        - \"lat_b\": latitude bounds for grid cell\n        - \"lon_b\": longitude bounds for grid cell\n\n    Notes\n    -----\n    Modified from ndpyramid - https://github.com/carbonplan/ndpyramid\n    \"\"\"\n\n    transform = rasterio.transform.Affine.translation(\n        te[0], te[3]\n    ) * rasterio.transform.Affine.scale((te[2] * 2) / tilesize, (te[1] * 2) / tilesize)\n\n    p = pyproj.Proj(dstSRS)\n\n    grid_shape = (tilesize, tilesize)\n    bounds_shape = (tilesize + 1, tilesize + 1)\n\n    xs = np.empty(grid_shape)\n    ys = np.empty(grid_shape)\n    lat = np.empty(grid_shape)\n    lon = np.empty(grid_shape)\n    lat_b = np.zeros(bounds_shape)\n    lon_b = np.zeros(bounds_shape)\n\n    # calc grid cell center coordinates\n    ii, jj = np.meshgrid(np.arange(tilesize) + 0.5, np.arange(tilesize) + 0.5)\n    for i, j in itertools.product(range(grid_shape[0]), range(grid_shape[1])):\n        locs = [ii[i, j], jj[i, j]]\n        xs[i, j], ys[i, j] = transform * locs\n        lon[i, j], lat[i, j] = p(xs[i, j], ys[i, j], inverse=True)\n\n    # calc grid cell bounds\n    iib, jjb = np.meshgrid(np.arange(tilesize + 1), np.arange(tilesize + 1))\n    for i, j in itertools.product(range(bounds_shape[0]), range(bounds_shape[1])):\n        locs = [iib[i, j], jjb[i, j]]\n        x, y = transform * locs\n        lon_b[i, j], lat_b[i, j] = p(x, y, inverse=True)\n\n    latitude = xr.DataArray(\n        lat[:, 0],\n        dims=\"y\",\n        attrs=dict(\n            standard_name=\"latitude\",\n            long_name=\"Latitude\",\n            units=\"degrees_north\",\n            axis=\"X\",\n        ),\n    )\n    longitude = xr.DataArray(\n        lon[0, :],\n        dims=\"x\",\n        attrs=dict(\n            standard_name=\"longitude\",\n            long_name=\"Longitude\",\n            units=\"degrees_east\",\n            axis=\"Y\",\n        ),\n    )\n\n    return xr.Dataset(\n        {\n            \"lat_b\": xr.DataArray(lat_b, dims=[\"y_b\", \"x_b\"]),\n            \"lon_b\": xr.DataArray(lon_b, dims=[\"y_b\", \"x_b\"]),\n        },\n        {\n            \"latitude\": latitude,\n            \"longitude\": longitude,\n        },\n    )\n\n\ndef xesmf_weights_to_xarray(regridder) -&gt; xr.Dataset:\n    \"\"\"\n    Construct an xarray dataset from XESMF weights\n\n    Notes\n    -----\n    From ndpyramid - https://github.com/carbonplan/ndpyramid\n    \"\"\"\n    w = regridder.weights.data\n    dim = \"n_s\"\n    ds = xr.Dataset(\n        {\n            \"S\": (dim, w.data),\n            \"col\": (dim, w.coords[1, :] + 1),\n            \"row\": (dim, w.coords[0, :] + 1),\n        }\n    )\n    ds.attrs = {\"n_in\": regridder.n_in, \"n_out\": regridder.n_out}\n    return ds\n\n\ndef _reconstruct_xesmf_weights(ds_w):\n    \"\"\"\n    Reconstruct weights into format that xESMF understands\n\n    Notes\n    -----\n    From ndpyramid - https://github.com/carbonplan/ndpyramid\n    \"\"\"\n\n    col = ds_w[\"col\"].values - 1\n    row = ds_w[\"row\"].values - 1\n    s = ds_w[\"S\"].values\n    n_out, n_in = ds_w.attrs[\"n_out\"], ds_w.attrs[\"n_in\"]\n    crds = np.stack([row, col])\n    return xr.DataArray(\n        sparse.COO(crds, s, (n_out, n_in)), dims=(\"out_dim\", \"in_dim\"), name=\"weights\"\n    )\n\n\nfrom common import earthaccess_args  # noqa: E402\nfrom common import target_extent as te  # noqa: E402\n\n# Define filepath, driver, and variable information\nargs = earthaccess_args[dataset]\n# Create icechunk repos for caching weights and target grid\nweights_storage = StorageConfig.s3_from_env(\n    bucket=\"nasa-veda-scratch\",\n    prefix=f\"resampling/test-weight-caching/{dataset}-weights\",\n    region=\"us-west-2\",\n)\ntarget_storage = StorageConfig.s3_from_env(\n    bucket=\"nasa-veda-scratch\",\n    prefix=f\"resampling/test-weight-caching/{dataset}-target\",\n    region=\"us-west-2\",\n)\n\nweights_store = IcechunkStore.open_or_create(storage=weights_storage, mode=\"w\")\ntarget_store = IcechunkStore.open_or_create(storage=target_storage, mode=\"w\")\n# Create target grid\ntarget_grid = make_grid_ds(te=te, tilesize=256, dstSRS=\"EPSG:3857\")\n\n\n# Open dataset\nstorage = StorageConfig.s3_from_env(\n    bucket=\"nasa-veda-scratch\",\n    prefix=f\"resampling/icechunk/{dataset}\",\n    region=\"us-west-2\",\n)\nstore = IcechunkStore.open_existing(storage=storage, mode=\"r\")\nda = xr.open_zarr(store, zarr_format=3, consolidated=False)[args[\"variable\"]]\nda\n\n\n# Chunk target grid for parallel weights generations\noutput_chunk_size = 128\ntarget_grid = target_grid.chunk(\n    {\n        \"x\": output_chunk_size,\n        \"y\": output_chunk_size,\n        \"y_b\": output_chunk_size,\n        \"x_b\": output_chunk_size,\n    }\n)\ntarget_grid\n\n\n# Create XESMF regridder\nregridder = xe.Regridder(\n    da,\n    target_grid,\n    \"nearest_s2d\",\n    periodic=True,\n    extrap_method=\"nearest_s2d\",\n    ignore_degenerate=True,\n    parallel=True,\n)\n\n\n# Convert weigts to a dataset\nweights = xesmf_weights_to_xarray(regridder)\n\n\n# Store weights using icechunk\nweights.to_zarr(weights_store, zarr_format=3, consolidated=False)\n# Commit data to icechunk stores\nweights_store.commit(\"Store weights\")\n\n\n# Store target grid using icechunk\ntarget_grid.load().to_zarr(target_store, zarr_format=3, consolidated=False)\ntarget_store.commit(\"Generate target grid\")\n\n\n# Store weights using Zarr\noutput = (\n    \"s3://nasa-veda-scratch/resampling/test-weight-caching/\" + dataset + \"-weights.zarr\"\n)\nweights.to_zarr(output, mode=\"w\", storage_options={\"use_listings_cache\": False})\n\n\n# Store target grid using Zarr\noutput = (\n    \"s3://nasa-veda-scratch/resampling/test-weight-caching/\" + dataset + \"-target.zarr\"\n)\ntarget_grid.to_zarr(output, mode=\"w\", storage_options={\"use_listings_cache\": False})",
    "crumbs": [
      "Resampling libraries",
      "XESMF (with pre-generated weights)",
      "Pre-generate weights"
    ]
  },
  {
    "objectID": "examples/process-results.html",
    "href": "examples/process-results.html",
    "title": "Process results",
    "section": "",
    "text": "import hvplot.pandas  # noqa\nfrom utils import process_results\ndf = process_results(\"results/2024-10-22\").sort_values([\"duration (s)\"])",
    "crumbs": [
      "Profiling results",
      "Memory and time usage (MURSST)"
    ]
  },
  {
    "objectID": "examples/process-results.html#show-memory-and-time-for-warp-resampling-dataset",
    "href": "examples/process-results.html#show-memory-and-time-for-warp-resampling-dataset",
    "title": "Process results",
    "section": "Show memory and time for warp resampling dataset",
    "text": "Show memory and time for warp resampling dataset\n\ndf = df[df[\"task\"] == \"resample\"]\ndf = df[df[\"virtual\"] != \"local\"]\ndf = df[df[\"dataset\"] == \"mursst\"]\ndf.style.background_gradient(cmap=\"YlOrRd\")\n\n\n\n\n\n\n \ndataset\ntask\nmethod\ndriver\nvirtual\npeak memory (GB)\nduration (s)\n\n\n\n\n33\nmursst\nresample\nrioxarray\nzarrv3\nicechunk\n9.997198\n14.185038\n\n\n32\nmursst\nresample\nrioxarray\nzarr\nicechunk\n9.997584\n15.843050\n\n\n26\nmursst\nresample\npyresample\nzarr\nicechunk\n39.143818\n23.006163\n\n\n27\nmursst\nresample\npyresample\nzarrv3\nicechunk\n39.140971\n23.013914\n\n\n22\nmursst\nresample\nodc\nzarr\nicechunk\n15.511851\n24.747759\n\n\n23\nmursst\nresample\nodc\nzarrv3\nicechunk\n15.507089\n25.981170\n\n\n30\nmursst\nresample\nrioxarray\nh5netcdf\n\n11.761108\n42.236852\n\n\n24\nmursst\nresample\npyresample\nh5netcdf\n\n39.162087\n45.690756\n\n\n20\nmursst\nresample\nodc\nh5netcdf\n\n15.531168\n54.914777\n\n\n29\nmursst\nresample\nrasterio\nnetcdf\nvsis3\n8.588360\n137.350257",
    "crumbs": [
      "Profiling results",
      "Memory and time usage (MURSST)"
    ]
  },
  {
    "objectID": "examples/resample-odc-h5netcdf-local.html",
    "href": "examples/resample-odc-h5netcdf-local.html",
    "title": "Resampling with ODC-geo (local storage, NetCDF File, H5NetCDF driver)",
    "section": "",
    "text": "import argparse\n\nimport fsspec\nimport xarray as xr\nfrom odc.geo.geobox import GeoBox\nfrom odc.geo.geom import Geometry\nfrom odc.geo.xr import crop, xr_reproject\nfrom shapely.geometry import box\n\n\ndef warp_resample(dataset):\n    from common import earthaccess_args\n    from common import target_extent as te\n\n    # Define filepath, driver, and variable information\n    args = earthaccess_args[dataset]\n    src = f'earthaccess_data/{args[\"filename\"]}'\n    # Define source and target projection\n    dstSRS = \"EPSG:3857\"\n    srcSRS = \"EPSG:4326\"\n    width = height = 256\n    # Specify fsspec caching since default options don't work well for raster data\n    fsspec_caching = {\n        \"cache_type\": \"none\",\n    }\n    fs = fsspec.filesystem(\"file\")\n    with fs.open(src, **fsspec_caching) as f:\n        # Define ODC geobox for target tile\n        gbox = GeoBox.from_bbox(te, dstSRS, shape=(height, width))\n        # Open dataset\n        da = xr.open_dataset(f, engine=\"h5netcdf\", chunks={})[args[\"variable\"]]\n        if dataset == \"gpm_imerg\":\n            # Transpose and rename dataset dims to align with GDAL expectations\n            da = (\n                da.rename({\"lon\": \"x\", \"lat\": \"y\"})\n                .transpose(\"time\", \"y\", \"x\")\n                .squeeze()\n            )\n        # Assign input projection\n        da = da.odc.assign_crs(srcSRS)\n        # Crop dataset to tile bounds\n        bbox = box(*te)\n        geom = Geometry(bbox, \"EPSG:3857\")\n        da = crop(da, geom)\n        if dataset == \"gpm_imerg\":\n            # Load into memory to avoid topology error\n            da.load()\n        # Reproject dataset\n        return xr_reproject(da, gbox).load()\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = warp_resample(\"gpm_imerg\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = warp_resample(user_args.dataset)",
    "crumbs": [
      "Resampling libraries",
      "Open Data Cube",
      "H5NetCDF Driver (Local storage)"
    ]
  },
  {
    "objectID": "examples/resample-odc-zarrv3-icechunk.html",
    "href": "examples/resample-odc-zarrv3-icechunk.html",
    "title": "Resampling with ODC-geo (S3 storage, Zarr V3 store, Zarr reader with icechunk)",
    "section": "",
    "text": "import argparse\n\nimport xarray as xr\nfrom icechunk import IcechunkStore, StorageConfig\nfrom odc.geo.geobox import GeoBox\nfrom odc.geo.geom import Geometry\nfrom odc.geo.xr import crop, xr_reproject\nfrom shapely.geometry import box\n\n\ndef warp_resample(dataset):\n    from common import earthaccess_args\n    from common import target_extent as te\n\n    # Define filepath, driver, and variable information\n    args = earthaccess_args[dataset]\n    # Open dataset\n    storage = StorageConfig.s3_from_env(\n        bucket=\"nasa-veda-scratch\",\n        prefix=f\"resampling/icechunk/{dataset}\",\n        region=\"us-west-2\",\n    )\n    store = IcechunkStore.open_existing(storage=storage, mode=\"r\")\n    da = xr.open_zarr(store, zarr_version=3, consolidated=False)[args[\"variable\"]]\n    # Define source and target projection\n    dstSRS = \"EPSG:3857\"\n    srcSRS = \"EPSG:4326\"\n    width = height = 256\n    # Define ODC geobox for target tile\n    gbox = GeoBox.from_bbox(te, dstSRS, shape=(height, width))\n    if dataset == \"gpm_imerg\":\n        # Transpose and rename dataset dims to align with GDAL expectations\n        da = da.rename({\"lon\": \"x\", \"lat\": \"y\"}).squeeze()\n    # Assign input projection\n    da = da.odc.assign_crs(srcSRS)\n    # Crop dataset to tile bounds\n    bbox = box(*te)\n    geom = Geometry(bbox, \"EPSG:3857\")\n    da = crop(da, geom)\n    if dataset == \"gpm_imerg\":\n        # Load into memory to avoid topology error\n        da.load()\n    # Reproject dataset\n    return xr_reproject(da, gbox, tight=True).load()\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = warp_resample(\"mursst\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = warp_resample(user_args.dataset)\n\n\nda.plot()"
  },
  {
    "objectID": "examples/resample-pyresample-h5netcdf-local.html",
    "href": "examples/resample-pyresample-h5netcdf-local.html",
    "title": "Resampling with pyresample (local storage, NetCDF File, H5NetCDF driver)",
    "section": "",
    "text": "import argparse\n\nimport fsspec\nimport xarray as xr\nfrom pyresample.area_config import create_area_def\nfrom pyresample.gradient import block_nn_interpolator, gradient_resampler_indices_block\nfrom pyresample.resampler import resample_blocks\n\n\ndef warp_resample(dataset):\n    from common import earthaccess_args\n    from common import target_extent as te\n\n    # Define filepath, driver, and variable information\n    args = earthaccess_args[dataset]\n    src = f'earthaccess_data/{args[\"filename\"]}'\n    # Define source and target projection\n    dstSRS = \"EPSG:3857\"\n    srcSRS = \"EPSG:4326\"\n    width = height = 256\n    # Specify fsspec caching since default options don't work well for raster data\n    fsspec_caching = {\n        \"cache_type\": \"none\",\n    }\n    fs = fsspec.filesystem(\"file\")\n    with fs.open(src, **fsspec_caching) as f:\n        # Open dataset\n        da = xr.open_dataset(f, engine=\"h5netcdf\", chunks={})[args[\"variable\"]]\n        # Rechunk MURSST to operate on fewer chunks\n        if dataset == \"mursst\":\n            da = da.chunk({\"time\": -1, \"lat\": 4000, \"lon\": 4000})\n        elif dataset == \"gpm_imerg\":\n            # Transpose dims to align with pyresample expectations\n            da = da.transpose(\"time\", \"lat\", \"lon\").squeeze()\n        # Create area definition for the target dataset\n        target_area_def = create_area_def(\n            area_id=1,\n            projection=dstSRS,\n            shape=(height, width),\n            area_extent=te,\n        )\n        # Create area definition for the source dataset\n        source_area_def = create_area_def(\n            area_id=2,\n            projection=srcSRS,\n            shape=(da.sizes[\"lat\"], da.sizes[\"lon\"]),\n            area_extent=[-179.995, 89.995, 180.005, -89.995],\n        )\n        # Compute indices for resampling\n        indices_xy = resample_blocks(\n            gradient_resampler_indices_block,\n            source_area_def,\n            [],\n            target_area_def,\n            chunk_size=(1, height, width),\n            dtype=float,\n        )\n        # Apply resampler\n        resampled = resample_blocks(\n            block_nn_interpolator,\n            source_area_def,\n            [da.data],\n            target_area_def,\n            dst_arrays=[indices_xy],\n            chunk_size=(1, height, width),\n            dtype=da.dtype,\n        )\n        # Reproject dataset\n        return resampled.compute()\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = warp_resample(\"gpm_imerg\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = warp_resample(user_args.dataset)",
    "crumbs": [
      "Resampling libraries",
      "Pyresample",
      "H5NetCDF Driver (Local storage)"
    ]
  },
  {
    "objectID": "examples/resample-pyresample-zarrv3-icechunk.html",
    "href": "examples/resample-pyresample-zarrv3-icechunk.html",
    "title": "Resampling with pyresample (S3 storage, Zarr V3 store, Zarr reader with icechunk)¶",
    "section": "",
    "text": "import argparse\n\nimport xarray as xr\nfrom icechunk import IcechunkStore, StorageConfig\nfrom pyresample.area_config import create_area_def\nfrom pyresample.gradient import block_nn_interpolator, gradient_resampler_indices_block\nfrom pyresample.resampler import resample_blocks\n\n\ndef warp_resample(dataset):\n    from common import earthaccess_args\n    from common import target_extent as te\n\n    # Define filepath, driver, and variable information\n    args = earthaccess_args[dataset]\n    # Open dataset\n    storage = StorageConfig.s3_from_env(\n        bucket=\"nasa-veda-scratch\",\n        prefix=f\"resampling/icechunk/{dataset}\",\n        region=\"us-west-2\",\n    )\n    store = IcechunkStore.open_existing(storage=storage, mode=\"r\")\n    da = xr.open_zarr(store, zarr_version=3, consolidated=False)[args[\"variable\"]]\n    # Define source and target projection\n    dstSRS = \"EPSG:3857\"\n    srcSRS = \"EPSG:4326\"\n    width = height = 256\n    # Rechunk MURSST to operate on fewer chunks\n    if dataset == \"mursst\":\n        da = da.chunk({\"lat\": 4000, \"lon\": 4000})\n    elif dataset == \"gpm_imerg\":\n        # Transpose dims to align with pyresample expectations\n        da = da.squeeze()\n    # Create area definition for the target dataset\n    target_area_def = create_area_def(\n        area_id=1,\n        projection=dstSRS,\n        shape=(height, width),\n        area_extent=te,\n    )\n    # Create area definition for the source dataset\n    source_area_def = create_area_def(\n        area_id=2,\n        projection=srcSRS,\n        shape=(da.sizes[\"lat\"], da.sizes[\"lon\"]),\n        area_extent=[-179.995, 89.995, 180.005, -89.995],\n    )\n    # Compute indices for resampling\n    indices_xy = resample_blocks(\n        gradient_resampler_indices_block,\n        source_area_def,\n        [],\n        target_area_def,\n        chunk_size=(1, height, width),\n        dtype=float,\n    )\n    # Apply resampler\n    resampled = resample_blocks(\n        block_nn_interpolator,\n        source_area_def,\n        [da.data],\n        target_area_def,\n        dst_arrays=[indices_xy],\n        chunk_size=(1, height, width),\n        dtype=da.dtype,\n    )\n    # Reproject dataset\n    return resampled.compute()\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = warp_resample(\"gpm_imerg\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = warp_resample(user_args.dataset)"
  },
  {
    "objectID": "examples/resample-rasterio-netcdf-vsis3.html",
    "href": "examples/resample-rasterio-netcdf-vsis3.html",
    "title": "Resampling with rasterio (S3 storage, NetCDF File, NetCDF4 driver, VSIS3 virtualization, earthaccess auth)",
    "section": "",
    "text": "import argparse\nimport json\n\nimport geopandas as gpd\nimport numpy as np\nimport rasterio\nfrom rasterio.mask import mask\nfrom rasterio.session import AWSSession\nfrom rasterio.warp import reproject\nfrom shapely.geometry import box\n\n\ndef configure_auth(daac):\n    \"\"\"Authenticate using earthaccess\"\"\"\n    import boto3\n    import earthaccess\n\n    auth = earthaccess.login()\n    s3_credentials = auth.get_s3_credentials(daac)\n    session = boto3.Session(\n        aws_access_key_id=s3_credentials[\"accessKeyId\"],\n        aws_secret_access_key=s3_credentials[\"secretAccessKey\"],\n        aws_session_token=s3_credentials[\"sessionToken\"],\n        region_name=\"us-west-2\",\n    )\n    rio_env = rasterio.Env(\n        AWSSession(session),\n    )\n    rio_env.__enter__()\n    return rio_env\n\n\ndef warp_resample(dataset):\n    from common import earthaccess_args\n    from common import target_extent as te\n\n    # Define filepath, driver, and variable information\n    args = earthaccess_args[dataset]\n    src = f'NETCDF:/vsis3/{args[\"bucket\"]}/{args[\"folder\"]}/{args[\"filename\"]}:{args[\"variable\"]}'\n    # Authenticate with earthaccess\n    with configure_auth(args[\"daac\"]):\n        # Define source and target projection\n        dstSRS = \"EPSG:3857\"\n        srcSRS = \"EPSG:4326\"\n        width = height = 256\n        with rasterio.open(src) as da:\n            # Clip dataset to bounds of Web Mercator tile\n            bbox = box(*te)\n            geo = gpd.GeoDataFrame(\n                {\"geometry\": bbox}, index=[0], crs=int(dstSRS.split(\":\")[1])\n            )\n            geo = geo.to_crs(crs=srcSRS)\n            coords = [json.loads(geo.to_json())[\"features\"][0][\"geometry\"]]\n            arr, src_transform = mask(da, shapes=coords, crop=True)\n            # Mask and fill array\n            ma = arr.astype(\"float32\", casting=\"unsafe\")\n            np.multiply(ma, da.scales[0], out=ma, casting=\"unsafe\")\n            np.add(ma, da.offsets[0], out=ma, casting=\"unsafe\")\n            # Define affine transformation from input to output dataset\n            dst_transform = rasterio.transform.from_bounds(*te, width, height)\n            # Create array to host results\n            destination = np.zeros((height, width), np.float32)\n            # Reproject dataset\n            _, transform = reproject(\n                ma.squeeze(),\n                destination,\n                src_crs=srcSRS,\n                src_transform=src_transform,\n                dst_crs=dstSRS,\n                dst_transform=dst_transform,\n            )\n            return destination\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = warp_resample(\"mursst\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = warp_resample(user_args.dataset)",
    "crumbs": [
      "Resampling libraries",
      "Rasterio",
      "NetCDF Driver (S3 storage)"
    ]
  },
  {
    "objectID": "examples/resample-rioxarray-h5netcdf-local.html",
    "href": "examples/resample-rioxarray-h5netcdf-local.html",
    "title": "Resampling with Rioxarray (Local storage, NetCDF file, H5NetCDF driver)",
    "section": "",
    "text": "import argparse\n\nimport fsspec\nimport rasterio as rio  # noqa\nimport xarray as xr\nfrom rasterio.warp import calculate_default_transform\n\n\ndef warp_resample(dataset):\n    from common import earthaccess_args\n    from common import target_extent as te\n\n    # Define filepath, driver, and variable information\n    args = earthaccess_args[dataset]\n    src = f'earthaccess_data/{args[\"filename\"]}'\n    # Define source and target projection\n    dstSRS = \"EPSG:3857\"\n    srcSRS = \"EPSG:4326\"\n    width = height = 256\n\n    # Specify fsspec caching since default options don't work well for raster data\n    fsspec_caching = {\n        \"cache_type\": \"none\",\n    }\n    fs = fsspec.filesystem(\"file\")\n    with fs.open(src, **fsspec_caching) as f:\n        # Open dataset\n        da = xr.open_dataset(f, engine=\"h5netcdf\", mask_and_scale=True)[\n            args[\"variable\"]\n        ]\n        if dataset == \"gpm_imerg\":\n            # Transpose and rename dims to align with rioxarray expectations\n            da = da.rename({\"lon\": \"x\", \"lat\": \"y\"}).transpose(\"time\", \"y\", \"x\")\n        # Set input dataset projection\n        da = da.rio.write_crs(srcSRS)\n        da = da.rio.clip_box(\n            *te,\n            crs=dstSRS,\n        )\n        # Define affine transformation from input to output dataset\n        dst_transform, w, h = calculate_default_transform(\n            srcSRS,\n            dstSRS,\n            da.rio.width,\n            da.rio.height,\n            *da.rio.bounds(),\n            dst_width=width,\n            dst_height=height,\n        )\n        # Reproject dataset\n        return da.rio.reproject(dstSRS, shape=(h, w), transform=dst_transform)\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = warp_resample(\"gpm_imerg\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = warp_resample(user_args.dataset)",
    "crumbs": [
      "Resampling libraries",
      "Rioxarray",
      "H5NetCDF Driver (Local storage)"
    ]
  },
  {
    "objectID": "examples/resample-rioxarray-zarrv3-icechunk.html",
    "href": "examples/resample-rioxarray-zarrv3-icechunk.html",
    "title": "Resampling with Rioxarray (S3 storage, Zarr V3 store, Zarr reader with icechunk)",
    "section": "",
    "text": "import argparse\n\nimport xarray as xr\nfrom icechunk import IcechunkStore, StorageConfig\nfrom rasterio.warp import calculate_default_transform\n\n\ndef warp_resample(dataset):\n    from common import earthaccess_args\n    from common import target_extent as te\n\n    # Define filepath, driver, and variable information\n    args = earthaccess_args[dataset]\n    # Open dataset\n    storage = StorageConfig.s3_from_env(\n        bucket=\"nasa-veda-scratch\",\n        prefix=f\"resampling/icechunk/{dataset}\",\n        region=\"us-west-2\",\n    )\n    store = IcechunkStore.open_existing(storage=storage, mode=\"r\")\n    da = xr.open_zarr(store, zarr_format=3, consolidated=False)[args[\"variable\"]]\n    # Define source and target projection\n    dstSRS = \"EPSG:3857\"\n    srcSRS = \"EPSG:4326\"\n    width = height = 256\n    if dataset == \"gpm_imerg\":\n        # Transpose and rename dims to align with rioxarray expectations\n        da = da.rename({\"lon\": \"x\", \"lat\": \"y\"})\n    # Set input dataset projection\n    da = da.rio.write_crs(srcSRS)\n    da = da.rio.clip_box(\n        *te,\n        crs=dstSRS,\n    )\n    # Define affine transformation from input to output dataset\n    dst_transform, w, h = calculate_default_transform(\n        srcSRS,\n        dstSRS,\n        da.rio.width,\n        da.rio.height,\n        *da.rio.bounds(),\n        dst_width=width,\n        dst_height=height,\n    )\n    # Reproject dataset\n    return da.rio.reproject(dstSRS, shape=(h, w), transform=dst_transform)\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = warp_resample(\"mursst\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = warp_resample(user_args.dataset)"
  },
  {
    "objectID": "examples/resample-xesmf-h5netcdf-local.html",
    "href": "examples/resample-xesmf-h5netcdf-local.html",
    "title": "Resampling with XESMF (local storage, NetCDF file, H5NetCDF driver)",
    "section": "",
    "text": "import argparse\nimport itertools\n\nimport fsspec\nimport numpy as np\nimport pyproj\nimport rasterio.transform\nimport xarray as xr\nimport xesmf as xe\n\n\ndef make_grid_ds(*, te, tilesize, dstSRS) -&gt; xr.Dataset:\n    \"\"\"\n    Make a dataset representing a target grid\n\n    Returns\n    -------\n    xr.Dataset\n        Target grid dataset with the following variables:\n        - \"x\": X coordinate in Web Mercator projection (grid cell center)\n        - \"y\": Y coordinate in Web Mercator projection (grid cell center)\n        - \"lat\": latitude coordinate (grid cell center)\n        - \"lon\": longitude coordinate (grid cell center)\n        - \"lat_b\": latitude bounds for grid cell\n        - \"lon_b\": longitude bounds for grid cell\n\n    Notes\n    -----\n    Modified from ndpyramid - https://github.com/carbonplan/ndpyramid\n    \"\"\"\n\n    transform = rasterio.transform.Affine.translation(\n        te[0], te[3]\n    ) * rasterio.transform.Affine.scale((te[2] * 2) / tilesize, (te[1] * 2) / tilesize)\n\n    p = pyproj.Proj(dstSRS)\n\n    grid_shape = (tilesize, tilesize)\n    bounds_shape = (tilesize + 1, tilesize + 1)\n\n    xs = np.empty(grid_shape)\n    ys = np.empty(grid_shape)\n    lat = np.empty(grid_shape)\n    lon = np.empty(grid_shape)\n    lat_b = np.zeros(bounds_shape)\n    lon_b = np.zeros(bounds_shape)\n\n    # calc grid cell center coordinates\n    ii, jj = np.meshgrid(np.arange(tilesize) + 0.5, np.arange(tilesize) + 0.5)\n    for i, j in itertools.product(range(grid_shape[0]), range(grid_shape[1])):\n        locs = [ii[i, j], jj[i, j]]\n        xs[i, j], ys[i, j] = transform * locs\n        lon[i, j], lat[i, j] = p(xs[i, j], ys[i, j], inverse=True)\n\n    # calc grid cell bounds\n    iib, jjb = np.meshgrid(np.arange(tilesize + 1), np.arange(tilesize + 1))\n    for i, j in itertools.product(range(bounds_shape[0]), range(bounds_shape[1])):\n        locs = [iib[i, j], jjb[i, j]]\n        x, y = transform * locs\n        lon_b[i, j], lat_b[i, j] = p(x, y, inverse=True)\n\n    return xr.Dataset(\n        {\n            \"x\": xr.DataArray(xs[0, :], dims=[\"x\"]),\n            \"y\": xr.DataArray(ys[:, 0], dims=[\"y\"]),\n            \"lat\": xr.DataArray(lat, dims=[\"y\", \"x\"]),\n            \"lon\": xr.DataArray(lon, dims=[\"y\", \"x\"]),\n            \"lat_b\": xr.DataArray(lat_b, dims=[\"y_b\", \"x_b\"]),\n            \"lon_b\": xr.DataArray(lon_b, dims=[\"y_b\", \"x_b\"]),\n        },\n    )\n\n\ndef regrid(dataset):\n    from common import earthaccess_args\n    from common import target_extent as te\n\n    # Define filepath, driver, and variable information    args = earthaccess_args[dataset]\n    args = earthaccess_args[dataset]\n    src = f'earthaccess_data/{args[\"filename\"]}'\n    # Create grid to hold result\n    target_grid = make_grid_ds(te=te, tilesize=256, dstSRS=\"EPSG:3857\")\n    # Specify fsspec caching since default options don't work well for raster data\n    fsspec_caching = {\n        \"cache_type\": \"none\",\n    }\n    fs = fsspec.filesystem(\"file\")\n    with fs.open(src, **fsspec_caching) as f:\n        # Open dataset\n        da = xr.open_dataset(f, engine=\"h5netcdf\", chunks={}, mask_and_scale=True)[\n            args[\"variable\"]\n        ]\n        # Create XESMF regridder\n        regridder = xe.Regridder(\n            da,\n            target_grid,\n            \"nearest_s2d\",\n            periodic=True,\n            extrap_method=\"nearest_s2d\",\n            ignore_degenerate=True,\n        )\n        # Regrid dataset\n        return regridder(da).load()\n\n\n%%time\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = regrid(\"gpm_imerg\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = regrid(user_args.dataset)",
    "crumbs": [
      "Resampling libraries",
      "XESMF",
      "H5NetCDF Driver (Local storage)"
    ]
  },
  {
    "objectID": "examples/resample-xesmf-zarrv3-icechunk.html",
    "href": "examples/resample-xesmf-zarrv3-icechunk.html",
    "title": "Resampling with XESMF (S3 storage, Zarr V3 store, Zarr reader with icechunk)¶",
    "section": "",
    "text": "import argparse\nimport itertools\n\nimport numpy as np\nimport pyproj\nimport rasterio.transform\nimport xarray as xr\nimport xesmf as xe\nfrom icechunk import IcechunkStore, StorageConfig\n\n\ndef make_grid_ds(*, te, tilesize, dstSRS) -&gt; xr.Dataset:\n    \"\"\"\n    Make a dataset representing a target grid\n\n    Returns\n    -------\n    xr.Dataset\n        Target grid dataset with the following variables:\n        - \"x\": X coordinate in Web Mercator projection (grid cell center)\n        - \"y\": Y coordinate in Web Mercator projection (grid cell center)\n        - \"lat\": latitude coordinate (grid cell center)\n        - \"lon\": longitude coordinate (grid cell center)\n        - \"lat_b\": latitude bounds for grid cell\n        - \"lon_b\": longitude bounds for grid cell\n\n    Notes\n    -----\n    Modified from ndpyramid - https://github.com/carbonplan/ndpyramid\n    \"\"\"\n\n    transform = rasterio.transform.Affine.translation(\n        te[0], te[3]\n    ) * rasterio.transform.Affine.scale((te[2] * 2) / tilesize, (te[1] * 2) / tilesize)\n\n    p = pyproj.Proj(dstSRS)\n\n    grid_shape = (tilesize, tilesize)\n    bounds_shape = (tilesize + 1, tilesize + 1)\n\n    xs = np.empty(grid_shape)\n    ys = np.empty(grid_shape)\n    lat = np.empty(grid_shape)\n    lon = np.empty(grid_shape)\n    lat_b = np.zeros(bounds_shape)\n    lon_b = np.zeros(bounds_shape)\n\n    # calc grid cell center coordinates\n    ii, jj = np.meshgrid(np.arange(tilesize) + 0.5, np.arange(tilesize) + 0.5)\n    for i, j in itertools.product(range(grid_shape[0]), range(grid_shape[1])):\n        locs = [ii[i, j], jj[i, j]]\n        xs[i, j], ys[i, j] = transform * locs\n        lon[i, j], lat[i, j] = p(xs[i, j], ys[i, j], inverse=True)\n\n    # calc grid cell bounds\n    iib, jjb = np.meshgrid(np.arange(tilesize + 1), np.arange(tilesize + 1))\n    for i, j in itertools.product(range(bounds_shape[0]), range(bounds_shape[1])):\n        locs = [iib[i, j], jjb[i, j]]\n        x, y = transform * locs\n        lon_b[i, j], lat_b[i, j] = p(x, y, inverse=True)\n\n    return xr.Dataset(\n        {\n            \"x\": xr.DataArray(xs[0, :], dims=[\"x\"]),\n            \"y\": xr.DataArray(ys[:, 0], dims=[\"y\"]),\n            \"lat\": xr.DataArray(lat, dims=[\"y\", \"x\"]),\n            \"lon\": xr.DataArray(lon, dims=[\"y\", \"x\"]),\n            \"lat_b\": xr.DataArray(lat_b, dims=[\"y_b\", \"x_b\"]),\n            \"lon_b\": xr.DataArray(lon_b, dims=[\"y_b\", \"x_b\"]),\n        },\n    )\n\n\ndef regrid(dataset):\n    from common import earthaccess_args\n    from common import target_extent as te\n\n    # Define filepath, driver, and variable information\n    args = earthaccess_args[dataset]\n    # Create grid to hold result\n    target_grid = make_grid_ds(te=te, tilesize=256, dstSRS=\"EPSG:3857\")\n    # Open dataset\n    storage = StorageConfig.s3_from_env(\n        bucket=\"nasa-veda-scratch\",\n        prefix=f\"resampling/icechunk/{dataset}\",\n        region=\"us-west-2\",\n    )\n    store = IcechunkStore.open_existing(storage=storage, mode=\"r\")\n    da = xr.open_zarr(store, zarr_format=3, consolidated=False)[args[\"variable\"]]\n    # Create XESMF regridder\n    regridder = xe.Regridder(\n        da,\n        target_grid,\n        \"nearest_s2d\",\n        periodic=True,\n        extrap_method=\"nearest_s2d\",\n        ignore_degenerate=True,\n    )\n    # Regrid dataset\n    return regridder(da).load()\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = regrid(\"gpm_imerg\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"mursst\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = regrid(user_args.dataset)"
  },
  {
    "objectID": "examples/resample-xesmfcached-h5netcdf-local.html",
    "href": "examples/resample-xesmfcached-h5netcdf-local.html",
    "title": "Resampling with XESMF (Local storage, NetCDF file, H5NetCDF driver, and pre-generated weights)",
    "section": "",
    "text": "import argparse\n\nimport fsspec\nimport numpy as np\nimport xarray as xr\nimport xesmf as xe\n\n\ndef _reconstruct_xesmf_weights(ds_w):\n    \"\"\"\n    Reconstruct weights into format that xESMF understands\n\n    Notes\n    -----\n    From ndpyramid - https://github.com/carbonplan/ndpyramid\n    \"\"\"\n    import sparse\n    import xarray as xr\n\n    col = ds_w[\"col\"].values - 1\n    row = ds_w[\"row\"].values - 1\n    s = ds_w[\"S\"].values\n    n_out, n_in = ds_w.attrs[\"n_out\"], ds_w.attrs[\"n_in\"]\n    crds = np.stack([row, col])\n    return xr.DataArray(\n        sparse.COO(crds, s, (n_out, n_in)), dims=(\"out_dim\", \"in_dim\"), name=\"weights\"\n    )\n\n\ndef reconstruct_weights(weights_fp):\n    \"\"\"\n    Reconstruct weights into format that xESMF understands\n\n    Notes\n    -----\n    From ndpyramid - https://github.com/carbonplan/ndpyramid\n    \"\"\"\n    return _reconstruct_xesmf_weights(xr.open_zarr(weights_fp))\n\n\ndef regrid(dataset):\n    from common import earthaccess_args  # noqa: 402\n\n    args = earthaccess_args[dataset]\n    # Load pre-generated weights and target dataset\n    weights_fp = (\n        \"s3://nasa-veda-scratch/resampling/test-weight-caching/\"\n        + dataset\n        + \"-weights.zarr\"\n    )\n    target_grid_fp = (\n        \"s3://nasa-veda-scratch/resampling/test-weight-caching/\"\n        + dataset\n        + \"-target.zarr\"\n    )\n    weights = reconstruct_weights(weights_fp)\n    grid = xr.open_zarr(target_grid_fp)\n    # Define filepath, driver, and variable information\n    src = f'earthaccess_data/{args[\"filename\"]}'\n    fs = fsspec.filesystem(\"file\")\n    # Specify fsspec caching since default options don't work well for raster data\n    fsspec_caching = {\n        \"cache_type\": \"none\",\n    }\n    with fs.open(src, **fsspec_caching) as f:\n        # Open dataset\n        da = xr.open_dataset(f, engine=\"h5netcdf\", mask_and_scale=True)[\n            args[\"variable\"]\n        ]\n        # Create XESMF regridder\n        regridder = xe.Regridder(\n            da,\n            grid,\n            \"nearest_s2d\",\n            periodic=True,\n            extrap_method=\"nearest_s2d\",\n            ignore_degenerate=True,\n            reuse_weights=True,\n            weights=weights,\n        )\n        # Regrid dataset\n        return regridder(da).load()\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = regrid(\"gpm_imerg\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"gpm_imerg\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = regrid(user_args.dataset)",
    "crumbs": [
      "Resampling libraries",
      "XESMF (with pre-generated weights)",
      "H5NetCDF Driver (Local storage)"
    ]
  },
  {
    "objectID": "examples/resample-xesmfcached-zarr-kerchunk.html",
    "href": "examples/resample-xesmfcached-zarr-kerchunk.html",
    "title": "Resampling with XESMF (S3 storage, NetCDF file, Zarr reader, kerchunk virtualization, and pre-generated weights)",
    "section": "",
    "text": "import argparse\n\nimport earthaccess\nimport fsspec\nimport numpy as np\nimport xarray as xr\nimport xesmf as xe\n\n\ndef _reconstruct_xesmf_weights(ds_w):\n    \"\"\"\n    Reconstruct weights into format that xESMF understands\n\n    Notes\n    -----\n    From ndpyramid - https://github.com/carbonplan/ndpyramid\n    \"\"\"\n    import sparse\n    import xarray as xr\n\n    col = ds_w[\"col\"].values - 1\n    row = ds_w[\"row\"].values - 1\n    s = ds_w[\"S\"].values\n    n_out, n_in = ds_w.attrs[\"n_out\"], ds_w.attrs[\"n_in\"]\n    crds = np.stack([row, col])\n    return xr.DataArray(\n        sparse.COO(crds, s, (n_out, n_in)), dims=(\"out_dim\", \"in_dim\"), name=\"weights\"\n    )\n\n\ndef reconstruct_weights(weights_fp):\n    \"\"\"\n    Reconstruct weights into format that xESMF understands\n\n    Notes\n    -----\n    From ndpyramid - https://github.com/carbonplan/ndpyramid\n    \"\"\"\n    return _reconstruct_xesmf_weights(xr.open_zarr(weights_fp))\n\n\ndef regrid(dataset):\n    from common import earthaccess_args  # noqa: 402\n\n    args = earthaccess_args[dataset]\n    # Load pre-generated weights and target dataset\n    weights_fp = (\n        \"s3://nasa-veda-scratch/resampling/test-weight-caching/\"\n        + dataset\n        + \"-weights.zarr\"\n    )\n    target_grid_fp = (\n        \"s3://nasa-veda-scratch/resampling/test-weight-caching/\"\n        + dataset\n        + \"-target.zarr\"\n    )\n    weights = reconstruct_weights(weights_fp)\n    grid = xr.open_zarr(target_grid_fp)\n    if dataset == \"gpm_imerg\":\n        src = f'earthaccess_data/{args[\"filename\"][:-4]}.json'\n    else:\n        src = f'earthaccess_data/{args[\"filename\"][:-3]}.json'\n    # Authenticate with earthaccess\n    s3_fs = earthaccess.get_s3fs_session(daac=args[\"daac\"])\n    storage_options = s3_fs.storage_options.copy()\n    # Specify fsspec caching since default options don't work well for raster data\n    fsspec_caching = {\n        \"cache_type\": \"none\",\n    }\n    # Open dataset using kerchunk\n    fs = fsspec.filesystem(\"reference\", fo=src, **fsspec_caching)\n    m = fs.get_mapper(\"\")\n    da = xr.open_dataset(\n        m,\n        engine=\"kerchunk\",\n        chunks={},\n        storage_options=storage_options,\n    )[args[\"variable\"]]\n    # Create XESMF regridder\n    regridder = xe.Regridder(\n        da,\n        grid,\n        \"nearest_s2d\",\n        periodic=True,\n        extrap_method=\"nearest_s2d\",\n        ignore_degenerate=True,\n        reuse_weights=True,\n        weights=weights,\n    )\n    # Regrid dataset\n    return regridder(da).load()\n\n\nif __name__ == \"__main__\":\n    if \"get_ipython\" in dir():\n        # Just call warp_resample if running as a Jupyter Notebook\n        da = regrid(\"gpm_imerg\")\n    else:\n        # Configure dataset via argpase if running via CLI\n        parser = argparse.ArgumentParser(description=\"Set environment for the script.\")\n        parser.add_argument(\n            \"--dataset\",\n            default=\"gpm_imerg\",\n            help=\"Dataset to resample.\",\n            choices=[\"gpm_imerg\", \"mursst\"],\n        )\n        user_args = parser.parse_args()\n        da = regrid(user_args.dataset)",
    "crumbs": [
      "Resampling libraries",
      "XESMF (with pre-generated weights)",
      "Zarr Reader + Kerchunk virtualization (S3 storage)"
    ]
  },
  {
    "objectID": "examples/run-memray.html",
    "href": "examples/run-memray.html",
    "title": "Geospatial reprojection in Python (2024)",
    "section": "",
    "text": "import subprocess\nfrom datetime import datetime\nfrom pathlib import Path\n\nimport fsspec\nfrom utils import sync_notebook\n\n\nfs = fsspec.filesystem(\"file\")\ncurrent_date = datetime.today().strftime(\"%Y-%m-%d\")\noutput_folder = f\"results/{current_date}/\"\nfs.mkdirs(output_folder, exist_ok=True)\n\n\ndataset = \"mursst\"\n\n\ndef run_memray(file: str):\n    output_file = output_folder + \"memray-\" + dataset + \"-\" + Path(file).stem + \".bin\"\n    summary_file = output_folder + \"memray-\" + dataset + \"-\" + Path(file).stem + \".json\"\n    command = [\n        \"memray\",\n        \"run\",\n        \"--force\",\n        \"--output\",\n        output_file,\n        file,\n        \"--dataset\",\n        dataset,\n    ]\n    subprocess.run(command)\n    summary_command = [\n        \"memray\",\n        \"stats\",\n        \"--force\",\n        \"--json\",\n        \"--output\",\n        summary_file,\n        output_file,\n    ]\n    subprocess.run(summary_command)\n\n\nif dataset == \"gpm_imerg\":\n    input_methods = [\"rioxarray\", \"odc\", \"pyresample\", \"rioxarray\", \"xesmf\"]\nelif dataset == \"mursst\":\n    input_methods = [\"odc\", \"pyresample\", \"rioxarray\", \"rasterio\"]\n\n\nnotebooks = []\nfor fp in input_methods:\n    notebooks.extend(fs.glob(f\"resample-{fp}*.ipynb\"))\n\n\nfor file in notebooks:\n    sync_notebook(file)\n\n\nmodules = []\nfor fp in input_methods:\n    modules.extend(fs.glob(f\"resample-{fp}*.py\"))\nfor file in modules:\n    # Skip kerchunk since it requires a different image build due to incompatibility with Zarr V3\n    if \"kerchunk\" not in file:\n        run_memray(file)\n\n\nmodules"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Warp resampling",
    "section": "",
    "text": "This a work-in-progress guidebook on existing warp resampling / reprojection methods in Python, along with some memory and statistical wall-time profiling results.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Warp resampling",
    "section": "",
    "text": "This a work-in-progress guidebook on existing warp resampling / reprojection methods in Python, along with some memory and statistical wall-time profiling results.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#caveat",
    "href": "index.html#caveat",
    "title": "Warp resampling",
    "section": "Caveat",
    "text": "Caveat\nThis is a WIP guidebook. We are presenting early on in the development to guide discussions and future work. The output from different resampling methods has not yet been verified, important parameters (e.g., target no_data values) have not been set, and not all methods have been implemented. We encourage people to contribute by building on the notebooks in the examples directory or participating in discussions on this repo or on the Pangeo discourse.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#memory-and-time-profiling",
    "href": "index.html#memory-and-time-profiling",
    "title": "Warp resampling",
    "section": "Memory and time profiling",
    "text": "Memory and time profiling\nResampling and reprojection (i.e., warp resampling) are essential steps for generating raster tiles for browser based visualization. Further, warp resampling is often one of the most time consuming and memory intensive portions of the tile generation process. The importance and complexity of this step motivates an exploration of different warp resampling options.\n\nGoals\nCompare memory and time performance for generating a zoom level 0 256 x 256 raster from one timestep and variable of the MUR SST dataset using the following approaches:\n\nosgeo.warp\nrasterio.warp.reproject\nrioxarray.reproject\npyresample.resample_blocks\nxesmf.Regridder\ngeoutils.Raster.reproject\nraster_tools.warp.reproject\nodc.geo.xr.xr_reproject\nxcube.resampling\ngeowombat.config.update\n\nOut-of-scope:\n\nxarray-regrid - only regrids within the same rectilinear coordinate system\nweatherbench2/regridding - only seems to regrid within the same rectilinear coordinate system\ndinosaur - only seems to regrid within the same rectilinear coordinate system\npygmt.grdproject - web mercator not amongst supported projections\nverde - not used for raster -&gt; raster resampling (only points -&gt; raster)\n\nThese methods will be run on the full resolution dataset. Nearest neighbor interpolation will be used for the first comparison. For simplicity, the amount of time necessary to generate a resampled array and the maximum amount of heap memory allocated will be measured.\n\n\nPlanned extensions\n\nCompare to results when using a 2x and 4x downsampled versions to better understand the time and memory complexity\nCompare to results when using a virtual dataset (e.g., VRT, Kerchunk reference file).\nCompare results when reading from a dataset stored locally versus in cloud object storage.\nCompare to results when using a cloud-optimized dataset (Zarr).\n\n\n\nPossible extensions\n\nCompare other resampling methods (e.g., bilinear, conservative).\nCompare with methods that don’t rely on existing packages (e.g., Conservative regridding with Xarray, GeoPandas, and Sparse and KDTree wrappers).\n\n\n\nEnvironment Setup\nThe notebooks can be run on a JupyterHub environment using the docker image quay.io/developmentseed/warp-resample-profiling:latest, which is created using repo2docker using the Dockerfile contained within the binder directory.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Warp resampling",
    "section": "References",
    "text": "References\n\nWhat’s Next - Software - Regridding\nLazy regridding discussion\n\n\nAcknowledgements\nThis work was made possible through support from NASA IMPACT. Numerous people have guided development, especially Aimee Barciauskas (@abarciauskas-bgse), Justus Magin (@keewis), and Michael Sumner (@mdsumner). The resources page contains references for source information. Quarto configuration based on Cloud Native Geospatial Formats Guide and the Tile Benchmarking(https://developmentseed.org/tile-benchmarking/). All mistakes my own.",
    "crumbs": [
      "Welcome"
    ]
  }
]